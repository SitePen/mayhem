interface IHandle {
	remove: () => void;
}

interface IMediator {
	routeState: Object;
	notify: (property:string, value:any) => void;
}

class Mediator {
	constructor(public routeState) {}
	notify(property:string, value:any) {

	}
}

interface IDataBinderRegistry {
	add(binder:IDataBinder, index:number): IHandle;
	test(binding:string, source:Object, destination:Object): boolean;
	bind(binding:string, source:Object, destination:Object): IDataBinderHandle;
}

// <Container title="{title}"><Text>a b {createUrl('foo')} d {e}</Text></Container>
// output is: string
// destination is: TextWidget#content

// destinations:
// 1. IWidget property

/*
in order for this to work,
we need:
1. a piece that asks for binding, provides an opaque property object to pass the new value, and performs whatever
   mutation is necessary when it changes.

   what this looks like is (this is generated by the templating system):



then

function readChildren(children:WidgetDescriptor[]) {

}

function readValue(value:any[]) {

}



2.*/

interface IDataBinder {
	test(binding:string, source:Object, destination:Object): boolean;
	bind(binding:string, source:Object, destination:Object, callback:(value:any) => void): IDataBinderHandle;
}

interface IComputedProperty {
	isComputed: boolean;
	get(): any;
	set?(value:any): void;
}

function computed(descriptor:/*Object*/any):IComputedProperty {
	descriptor = <IComputedProperty> Object.create(descriptor, {
		isComputed: { value: true }
	});

	return descriptor;
}

var mediator:IMediator = new Mediator({
	routeState: null,
	computedProperty: computed({
		get: function () {
			return this.a + ' ' + this.b;
		},
		set: function (value:any) {
			value = value.split(' ');
			this.set({
				a: value[0],
				b: value[1]
			});
		}
	})
});

interface IDataBinderHandle extends IHandle {
	notify(value:any): void;
}

class DefaultDataBinder implements IDataBinder {
	test(binding:string) {


		return true;
	}

	bind(binding:string, context:IMediator) {
		var property:string = 'foo';
		if(context[property].isComputed){}

		return {
			remove: function () {

			}
		};
	}
}

interface IStyle {
	// Combined styles interface for multiple platform support
	background: IBackgroundStyle;
	textColor: IColor;
	/* etc. */
}

/* class */ interface IColor {
	r: number;
	g: number;
	b: number;
	h: number;
	s: number;
	l: number;
	a: number;
	toHex(): string;
	toString(): string;
}

/* not all widget backends would support all background features; we are just starting with HTML/CSS for now */
interface IBackgroundStyle {
	color: IColor;
	images: IBackgroundImage[];
}

interface IBackgroundImage {
	attachment: string /* should be enum */;
	clip: string /* should be enum */;
	origin: string /* should be enum */;
	position: string /* should be enum */
	repeat: BackgroundRepeat;
	size: string /* should be enum */
	url: string;
}

enum BackgroundRepeat {
	X,
	Y,
	XY,
	NONE
}

interface IClassList { // stateful array instead?
	add(className:string): void;
	has(className:string): boolean;
	remove(className:string): void;
	toggle(className:string, forceState?:boolean): void;
}

interface IExtensionEvent extends CustomEvent {}

interface IExtensionEventListener {
	(target:IWidget, callback:(event:IExtensionEvent) => void): IHandle;
}

enum AddPosition {
	FIRST = -1,
	LAST = -2
}

enum PlacePosition {
	FIRST = -1,
	LAST = -2,
	BEFORE = -3,
	AFTER = -4,
	ONLY = -5,
	REPLACE = -6
}

interface IWidget {
	style: IStyle;
	classList: IClassList;
	constructor(kwArgs:Object): void;
	on(eventName:string, callback:(event:CustomEvent) => void): IHandle;
	on(extensionEvent:IExtensionEventListener): IHandle;
	emit(event:CustomEvent): void;
	placeAt(destination:IContainer, position?:PlacePosition): IHandle;
	placeAt(destination:IContainer, position?:number): IHandle;
	bind(propertyName:string, binding:string): IDataBinderHandle;
//	watch(callback:(value:any, oldValue:any, name:string) => any): IHandle; // not sure about this one. dbind? promises?
//	watch(name:string, callback:(value:any, oldValue:any, name:string) => any): IHandle; // not sure about this one. dbind? promises?
	destroy(): void;
}

interface IContainer extends IWidget {
	add(widget:IWidget, position?:AddPosition): IHandle;
	add(widget:IWidget, position?:number): IHandle;
	children: IWidget[];
	getChildIndex(child:IWidget): number; // not sure about this one. platform limitations?
	remove(childIndex:number): void;     // not sure about this one. platform limitations?
	remove(child:IWidget): void;          // not sure about this one. always use handle?
}

interface IContained { // not sure about this. integrate with Widget interface?
	previous: IWidget;
	next: IWidget;
	parent: IContainer;
}

interface IView extends IWidget {
	mediator: IMediator;
}
