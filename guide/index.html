<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<title>Mayhem ◇ User guide</title>
		<link rel="stylesheet" href="css/main.css">
		<script>
(function () {
	var test = document.createElement('b');
	for (var prefix in { '': 1, '-webkit-': 1 }) {
		var position = prefix + 'sticky';
		test.style.position = position;
		if (test.style.position === position) {
			return;
		}
	}
	document.documentElement.classList.add('no-sticky');
})();
		</script>
	</head>
	<body>
		<span role="button" id="showMenu" class="icon-menu"
			aria-controls="tableOfContents"
			aria-expanded="false"
			tabindex="0"
			title="Table of contents">Menu</span>
		<header class="header">
			<div class="wrapper">
				<div class="preTitle">
					<a class="logo" href=""><img alt="Mayhem logo"></a>
					<nav id="mainMenu">
						<ul>
							<li><a href="">About</a></li>
							<li><a href=""><span class="hide-680">User </span>guide</a></li>
							<li><a href="">API<span class="hide-680"> reference</span></a></li>
							<li><a href="">Community</a></li>
						</ul>
					</nav>
				</div>
				<div id="initialScrollPoint">
					<label class="search" role="search">
						<input type="text">
						<span class="icon-search"></span>
					</label>
					<h1 class="title"><span class="bold">Mayhem</span> user guide</h1>
				</div>
				<script>
(function () {
	if (window.scrollY === 0 && !location.hash && !document.documentElement.classList.contains('no-sticky')) {
		document.documentElement.style.minHeight = (window.innerHeight + /* $lh */ 32) + 'px';
		var scrollTo = document.getElementById('initialScrollPoint');
		window.scrollTo(window.scrollX, scrollTo.getBoundingClientRect().top);
	}
})();
				</script>
			</div>
		</header>

		<div class="content">
			<div class="wrapper">
				<nav class="nav" id="tableOfContents">
					<ul>
						<li data-id="getting-started">
							<a href="#getting-started">Getting started</a>
							<ul class="subsections">
								<li data-id="what-is-mayhem"><a href="#what-is-mayhem">What is Mayhem?</a></li>
								<li data-id="system-requirements"><a href="#system-requirements">System requirements</a></li>
								<li data-id="installation"><a href="#installation">Installation</a></li>
								<li data-id="reading-guide"><a href="#reading-guide">Reading this guide</a></li>
								<li data-id="first-app"><a href="#first-app">Creating your first app</a></li>
							</ul>
						</li>
						<li data-id="fundamentals">
							<a href="#fundamentals">Fundamentals</a>
							<ul class="subsections">
								<li data-id="fundamentals-overview"><a href="#fundamentals-overview">Overview</a></li>
								<li data-id="typescript"><a href="#typescript">The TypeScript language</a></li>
								<li data-id="mvvm"><a href="#mvvm">The MVVM pattern</a></li>
								<li data-id="conventions"><a href="#conventions">Conventions</a></li>
								<li data-id="base-object"><a href="#base-object">The Base object</a></li>
							</ul>
						</li>
						<li data-id="application">
							<a href="#application">Applications</a>
							<ul class="subsections">
								<li data-id="application-class"><a href="#application-class">Creating an application</a></li>
								<li data-id="application-components"><a href="#application-components">Application components</a></li>
							</ul>
						</li>
						<li data-id="data-binding">
							<a href="#data-binding">Data binding</a>
							<ul class="subsections">
								<li data-id="what-is-data-binding"><a href="#what-is-data-binding">What is data binding?</a></li>
								<li data-id="how-to-data-bind"><a href="#how-to-data-bind">How to bind data in Mayhem</a></li>
								<li data-id="binding-arrays"><a href="#binding-arrays">Binding to arrays and collections</a></li>
								<li data-id="extending-binding"><a href="#extending-binding">Adding and extending bindings</a></li>
							</ul>
						</li>
						<li>
							<a href="#routing">Routing</a>
							<ul class="subsections">
								<li data-id="what-is-routing"><a href="#what-is-routing">What is routing?</a></li>
								<li data-id="defining-routes"><a href="#defining-routes">Defining routes &amp; URLs</a></li>
								<li data-id="writing-routes"><a href="#writing-routes">Writing routes</a></li>
							</ul>
						</li>
						<li>
							<a href="#views">Views</a>
							<ul class="subsections">
								<li data-id="mayhem-views"><a href="#mayhem-views">How views work</a></li>
								<li data-id="view-templating"><a href="#view-templating">View templating</a></li>
								<li data-id="cross-platform-views"><a href="#cross-platform-views">Using cross-platform views</a></li>
								<li data-id="event-system"><a href="#event-system">The event system</a></li>
								<li data-id="custom-platform-widgets"><a href="#custom-platform-widgets">Custom platform widgets</a></li>
							</ul>
						</li>
						<li>
							<a href="#collections">Collections</a>
							<ul class="subsections">
								<li data-id="what-is-collection"><a href="#what-is-collection">What is a collection?</a></li>
								<li data-id="creating-collections"><a href="#creating-collections">Creating collections</a></li>
								<li data-id="wrapping-collections"><a href="#wrapping-collections">Creating view model collections</a></li>
							</ul>
						</li>
						<li>
							<a href="#data-models">Data models</a>
							<ul class="subsections">
								<li data-id="mayhem-model"><a href="#mayhem-model">Data model basics</a></li>
								<li data-id="tracking-model-changes"><a href="#tracking-model-changes">Tracking model changes</a></li>
								<li data-id="scenarios"><a href="#scenarios">Scenarios</a></li>
								<li data-id="validation"><a href="#validation">Validation</a></li>
							</ul>
						</li>
						<li>
							<a href="#i18n">Internationalisation</a>
							<ul class="subsections">
								<li data-id="i18n-object"><a href="#i18n-object">The I18n object</a></li>
								<li data-id="i18n-messages"><a href="#i18n-messages">Translating messages</a></li>
								<li data-id="i18n-numbers-dates"><a href="#i18n-numbers-dates">Numbers &amp; dates</a></li>
							</ul>
						</li>
						<li>
							<a href="#security">Security</a>
							<ul class="subsections">
								<li data-id="user-object"><a href="#user-object">The User object</a></li>
								<li data-id="rbac"><a href="#rbac">Role-based access control</a></li>
							</ul>
						</li>
						<li>
							<a href="#testing">Testing</a>
							<ul class="subsections">
								<li data-id="testing-apps"><a href="#testing-apps">Testing Mayhem apps</a></li>
							</ul>
						</li>
						<li>
							<a href="#optimising">Optimising</a>
							<ul class="subsections">
								<li data-id="creating-builds"><a href="#creating-builds">Creating builds</a></li>
							</ul>
						</li>
						<li>
							<a href="#community">Community</a>
							<ul class="subsections">
								<li data-id="getting-help"><a href="#getting-help">Getting help</a></li>
								<li data-id="contributing"><a href="#contributing">Contributing</a></li>
							</ul>
						</li>
					</ul>

					<p class="support"><a href="https://sitepen.com/support/index.html">Commercial support</a></p>
				</nav>

				<main class="main" id="main">
					<article>
						<div class="a" id="getting-started"></div>
						<h2 data-id="getting-started">Welcome to Mayhem</h2>

						<div class="a half" id="what-is-mayhem"></div>
						<h3 data-id="what-is-mayhem">What is Mayhem?</h3>

						<aside class="whatAreYouCrazy">
							<p>This guide is a work in progress, with many details not yet finished, any many broken links as a result. <a href="https://github.com/SitePen/mayhem/blob/master/CONTRIBUTING.md">Contributing</a> to this guide is a great way to get involved with Mayhem!</p>
						</aside>

						<p>Mayhem is a framework for developing large, complex applications with TypeScript or JavaScript. Unlike other Web libraries and frameworks that place absolute emphasis on performance or file size, Mayhem is designed around these three key tenets:</p>

						<ul>
							<li><strong>Predictability</strong>: As much as possible, the framework must be designed to minimise surprise. Mayhem uses as little magic as possible in order to accomplish its goals, while still being exceptionally powerful &amp; easy to use, with a minimum of rote.</li>
							<li><strong>Extensibility</strong>: It must be possible for all parts of the framework to be easily extended or replaced with newer, better components. This allows many different classes of applications to be written, including those not envisioned when the framework was originally written, using the same standard set of tools.</li>
							<li><strong>Correctness</strong>: When writing software, it’s frustrating when your tools get you stuck. Mayhem was architected from the ground up to be modular, testable, and easy to understand in order to minimise the maintenance cost surrounding its use.</li>
						</ul>

						<p>We believe that good architecture, in combination with today’s superfast JavaScript engines, ensures a very high level of performance in nearly all use cases. As such, the clarity and maintainability of the Mayhem codebase will always be given priority over performance tweaks in all but the hottest code paths. We hope that you will see the benefit of this decision in increased productivity and less time spent troubleshooting your apps!</p>

						<h4>What is Mayhem best for?</h4>

						<p>Mayhem is a general purpose application development framework that can be used for developing virtually any type of client-side, server-side, or mobile application. Because of its emphasis on strict architectural patterns and conventions, it is especially well-suited for extremely large, “enterprise-level” applications that must be maintained by large teams of developers with varying skill levels.</p>

						<p>This first release of Mayhem focuses primarily on the development of form-based client-side Web applications, but we plan on rapidly expanding functionality for other types of apps. <a href="https://github.com/SitePen/mayhem/blob/master/CONTRIBUTING.md">Pull requests are accepted!</a></p>

						<div class="a half" id="system-requirements"></div>
						<h3 data-id="system-requirements">System requirements</h3>

						<p>End-users of Mayhem applications must meet the following minimum system requirements:</p>

						<table>
							<tr>
								<td>Android</td>
								<td>4.1.2+</td>
							</tr>
							<tr>
								<td>Chrome</td>
								<td>Latest</td>
							</tr>
							<tr>
								<td>Firefox</td>
								<td>Latest <abbr title="Extended Support Release">ESR</abbr> or rapid release</td>
							</tr>
							<tr>
								<td>Internet Explorer</td>
								<td>8+</td>
							</tr>
							<tr>
								<td>iOS</td>
								<td>6.1+</td>
							</tr>
							<tr>
								<td>Opera</td>
								<td>Latest</td>
							</tr>
							<tr>
								<td>Safari (Mac OS)</td>
								<td>Latest</td>
							</tr>
						</table>

						<p>Developers using Mayhem must also meet the following additional requirements:</p>

						<table>
							<tr>
								<td><a href="http://bower.io">Bower</a></td>
								<td>1.3.9+</td>
								<td>for client-side package installation</td>
							</tr>
							<tr>
								<td><a href="http://nodejs.org">Node.js</a></td>
								<td>0.10.28+</td>
								<td>for builds &amp; functional testing</td>
							</tr>
							<tr>
								<td><a href="http://npmjs.org">npm</a></td>
								<td>1.4.4+</td>
								<td>for Node.js package installation</td>
							</tr>
						</table>

						<div class="a half" id="installation"></div>
						<h3 data-id="installation">Installation</h3>

						<p>Depending upon the platform you are planning on developing for, there are three different ways in which installation can be performed:</p>

						<ul>
							<li><strong>For writing Node.js apps</strong>: Mayhem can be installed for use with Node.js by running <code>npm install mayhem</code>. This will install a copy of Mayhem that has been pre-compiled for Node.js using the CommonJS module format, plus ambient declarations that can be used when writing Mayhem applications for Node.js with TypeScript.</li>
							<li><strong>For writing browser &amp; mobile apps</strong>: Mayhem can be installed for browsers &amp; mobile devices by running <code>bower install mayhem</code>. This will install a copy of Mayhem that has been pre-compiled for asynchronously loaded environments using the <abbr title="Asynchronous Module Definition">AMD</abbr> module format, plus ambient declarations that can be used when writing Mayhem applications for browsers or mobile devices with TypeScript. Bower can be installed from npm by running <code>npm install -g bower</code>.</li>
							<li><strong>For working on Mayhem, or compiling your own modules</strong>: The original TypeScript source for Mayhem can be installed from our <a href="https://github.com/SitePen/mayhem" title="Mayhem on GitHub">GitHub repository</a> by running <code>git clone --recursive git@github.com:SitePen/mayhem.git</code>. The README file in the repository contains additional instructions on installation and usage of the development version of Mayhem.</li>
						</ul>

						<p>Because Mayhem is written in TypeScript, future versions of Mayhem will also be compiled to standard EcmaScript 6 modules once that format has been finalised.</p>

						<div class="a half" id="reading-guide"></div>
						<h3 data-id="reading-guide">Reading this guide</h3>

						<p>Throughout this guide, you will find certain pieces of information are called out specifically, as we have found them to be especially important or problematic for users.</p>

						<aside class="tip">
							<p>Sections that look like this contain advanced tips and tricks that can help you get the most out of Mayhem.</p>
						</aside>

						<aside class="deprecated">
							<p>Sections that look like this tell you about functionality that is deprecated and will be removed from a future version of Mayhem.</p>
						</aside>

						<aside class="whatAreYouCrazy">
							<p>Sections that look like this tell you about dangerous anti-patterns that can break, slow down, or make your application less maintainable.</p>
						</aside>

						<p>Later sections of this guide are designed to be built upon knowledge presented in earlier parts. If you jump into the middle and feel confused, step back a section or two until you find the information you need to move forward. We also accept <a href="https://github.com/SitePen/mayhem/blob/master/CONTRIBUTING.md">pull requests</a> to the documentation in order to improve its flow and clarity.</p>

						<div class="a half" id="first-app"></div>
						<h3 data-id="first-app">Creating your first app</h3>

						<p>In order to simplify the creation of new applications, Mayhem comes with a command-line generator that can be used to instantly generate new applications.</p>

						<aside class="tip"><p>In the first release of Mayhem, the <span class="sc">Mayhem generator</span> generates Web applications only. Future versions will contain additional default application profiles for many other kinds of apps.</p></aside>

						<p>To get started, just run the generator for starting a Web application:</p>

						<pre class="m1"><code class="bash">$ yo mayhem webapp src</code></pre>

						<p>This will create a new skeleton Web app in the <code>src</code> directory (actually, a TodoMVC app). All that needs to be done now is to open the test application in a browser:</p>

						<pre class="m1"><kbd>http://localhost/path/to/src/index.html</kbd></pre>

						<p>Navigating to this index page should display a fully functioning client-side TodoMVC application, ready for you to start hacking away!</p>

						<aside class="tip"><p>The <span class="sc">Mayhem generator</span> does more than just scaffold a basic app: It automatically generate new models quickly and easily; allows you to generate routing configurations for apps that don’t have direct access to the filesystem to safely auto-discover the available views; and watches for and automatically recompiles changed TypeScript and Stylus files. Just run <kbd>yo mayhem</kbd> to get an overview of all the available commands.</p></aside>

						<p>TODO: Continue tutorialising the basic TodoMVC app; maybe add in user authentication or something.</p>
					</article>

					<article>
						<div class="a" id="fundamentals"></div>
						<h2 data-id="fundamentals">Fundamentals</h2>

						<p>TODO: Describe core technologies like AMD, Promises, …</p>

						<div class="a half" id="fundamentals-overview"></div>
						<h3 data-id="fundamentals-overview">Overview</h3>

						<figure>
							<!--<embed class="svgImage" src="images/mayhem-subsystems.svg" type="image/svg+xml" height="550" width="100%">-->
							<img src="images/mayhem-subsystems.png">
							<figcaption>The subsystems of Mayhem</figcaption>
						</figure>

						<p>The architecture of Mayhem is divided up into eight primary subsystems:</p>

						<ul>
							<li><strong>Application</strong>: The <dfn>application subsystem</dfn> is responsible for providing a mechanism for creating new applications by configuration, dynamically loading application components at runtime using dependency injection, and providing a main application-wide object for each application that is currently running in the environment.</li>
							<li><strong>Data binding</strong>: The <dfn>data binding subsystem</dfn> is responsible for all functionality related to binding properties between two objects, and observing properties on objects for changes. This subsystem is essential for implementing the MVVM pattern, which will be discussed shortly.</li>
							<li><strong>Data modelling</strong>: The <dfn>data modelling subsystem</dfn> provides functionality related to business logic, data object creation, data validation, and communication with databases.</li>
							<li><strong>Foundation</strong>: The <dfn>foundation subsystem</dfn> provides core functionality for the entire Mayhem application framework, like observable proxy objects, utility functions, and other miscellaneous critical functionality.</li>
							<li><strong>Routing</strong>: The <dfn>routing subsystem</dfn> is responsible for discovering, loading, and linking together data models and sub-views in response to navigation within an application.</li>
							<li><strong>Security</strong>: The <dfn>security subsystem</dfn> is responsible for providing user authentication &amp; authorization, access control, and other security-oriented application functionality.</li>
							<li><strong>Templating</strong>: The <dfn>templating subsystem</dfn> is responsible for creating views and linking data models to the views using easy-to-write declarative templates.</li>
							<li><strong>Views</strong>: The <dfn>view subsystem</dfn> is responsible for handling all <abbr title="User Interface">UI</abbr> input and output, and providing an abstraction layer over the platform’s own UI system.</li>
						</ul>

						<div class="a half" id="typescript"></div>
						<h3 data-id="typescript">The TypeScript language</h3>

						<p>Mayhem is written in <a href="http://typescriptlang.org">TypeScript</a> in order to take advantage of the significant maintenance benefits that come with optional strict typing and the ability to define strong interfaces. Since these features are also critical to keeping large applications maintainable over many years—especially with teams of varying disciplines and skill levels—we strongly encourage all users of Mayhem to explore using TypeScript directly when writing apps with Mayhem. However, the TypeScript compiler does generate highly-readable, well-formed JavaScript, so if you prefer to use vanilla JavaScript, go right ahead!</p>

						<aside class="tip"><p>If you’re unfamiliar with TypeScript but want to learn how to use it, check out SitePen’s <a href="http://www.sitepen.com/blog/2013/12/31/definitive-guide-to-typescript/">Definitive Guide to TypeScript</a>. Remember that TypeScript is a full superset of JavaScript, so you can always write JavaScript and migrate to TypeScript over time—or vice-versa!</p></aside>

						<div class="a half" id="mvvm"></div>
						<h3 data-id="mvvm">The MVVM pattern</h3>

						<figure>
							<img src="http://placekitten.com/600/320">
							<figcaption>An overview of the MVVM pattern</figcaption>
						</figure>

						<p>Mayhem implements the model–view–view-model (<dfn>MVVM</dfn>) architectural pattern, which separates business logic, user interface logic, and the user interface itself into three distinct layers. This pattern is similar to the Smalltalk <abbr title="model-view-controller">MVC</abbr> pattern (not to be confused with <a href="https://en.wikipedia.org/wiki/Model_2">Model 2 MVC</a>, a pattern used by server-side MVC frameworks), but it uses an improved mode of interaction between the different layers in order to avoid the “fat controller” anti-pattern common to many MVC apps.</p>

						<h4>Model</h4>

						<p>The term <dfn>model</dfn> in the context of the MVVM pattern refers to a “business” object—an object that contains code and data that performs the actual work of the business. Models operate completely independently from any user interface, so can be fully reused across many different systems. For example, if you were writing software for managing a bank, <em>bank accounts</em> and <em>transactions</em> would be two different types of <em>models</em>. Models within Mayhem are normally created by subclassing the <!--<a href="#TODO">--><code>mayhem/data/Model</code><!--</a>--> class, which provides standard functionality for defining, loading, validating, and saving data.</p>

						<h4>View</h4>

						<p>The term <dfn>view</dfn> in the context of the MVVM pattern refers to an object representing part of the interactive user interface of an application. Views encapsulate both input and output: they display data to the user in the form of widgets and sub-views, and collect and dispatch user input (mouse, touch, pen, keyboard, Kinect, etc.) from the user interface back to the rest of the system, usually by calling a method on a view-model.</p>

						<h4>View-model</h4>

						<p>The term <dfn>view-model</dfn> refers to a Model object that exposes properties that are required by a specific view. For example, if you had a <em>transaction history view</em> in your application, you would create an associated view-model that exposed a <a href="https://github.com/SitePen/dstore/blob/master/docs/Collection.md">Collection</a> of <code>Transaction</code> objects to display in the list, plus additional properties that could be updated by the view in order to dynamically change the contents of the <code>Transactions</code> collection.</p>

						<p>One of the key differences between an MVVM view-model and an MVC controller is that the view-model is never given a reference to its associated view. Instead, properties are [TODO: should talk about data binding before getting here?] data-bound between the view and the view-model, so that when something in the view changes, a bound property of the view-model is updated, and vice-versa. This approach allows view-models to be decoupled from and reused by multiple different views, and also allows their logic to be tested completely independently from any user interface. It also has the added benefit of preventing any UI-specific code from ending up outside of the view subsystem.</p>

						<p>In many cases, view-models are simple proxies back to real data models. For example, while a Transaction model may store the amount of a transaction in USD cents, your view may want to display the transaction amount in its equivalent in euros, with the correct currency symbol and locale-specific number formatting. Since all other information—like the transaction ID and recipient—can be taken as-is from the original data model, there is no reason to create an entirely separate view-model that re-exposes these properties just to add this one extra piece for the view. <!--<a href="TODO">--><code>mayhem/data/ProxyModel</code>s<!--</a>--> allow you to wrap an existing model object with extra properties for display in a view, with all other properties delegating back to the original data model.</p>

						<div class="a half" id="conventions"></div>
						<h3 data-id="conventions">Conventions</h3>

						<p>Mayhem uses conventions that enable features similar to those only available in EcmaScript 6+ to be used in environments going back to EcmaScript 3. Because these conventions are used throughout code written with Mayhem, it is important to understand these conventions and why they exist. Over time, as the TypeScript compiler improves and support for older platforms is dropped, code written with Mayhem will become much more concise and easier to author.</p>

						<h4>Object construction</h4>

						<p>All constructors in Mayhem share the same constructor signature, with a single optional <dfn>keyword arguments</dfn> object accepted as the sole argument:</p>

						<pre><code class="typescript">{ new (kwArgs?:Object):&lt;ClassType>; }</code></pre>

						<p>By passing all arguments to a constructor using a keyword arguments object instead of allowing arbitrary constructor parameters, many things become easier:</p>

						<ul>
							<li>Constructors can always be extended in a backwards-compatible manner, since new properties can simply be added to the list of accepted properties without a signature change</li>
							<li>Constructors can always be indirectly invoked using the <code>new</code> keyword, with <a href="https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible" title="“Use of .apply() with 'new' operator. Is this possible?” on Stack Overflow">no additional overhead in pre-ES6 environments</a></li>
							<li>All arguments are clear from the call itself and do not <a href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event-initMouseEvent" title="The DOM 2 Event#initMouseEvent API, featuring 6 number and 6 boolean parameters">require looking at the constructor’s parameter list</a></li>
							<li>No extra code is necessary for parameters that need to go through accessors/mutators, as the keyword arguments object is mass-assigned at construction time</li>
						</ul>

						<h4>Default object properties</h4>

						<p>Due to <!--<a href="TODO">-->design limitations<!--</a>--> in TypeScript 1, default property values should be defined by adding an <!--<a href="TODO">--><code>_initialize</code><!--</a>--> function to subclasses instead of using the syntactic sugar for default properties built into TypeScript’s class syntax:</p>

						<pre><code class="typescript">class Burger extends Observable {
	hasCheese:boolean;

	protected _initialize() {
		super._initialize();
		this.hasCheese = false;
	}
}</code></pre>

						<p>It is expected that future revisions to TypeScript will re-enable the use of the default property value syntax without breaking the ability to use keyword arguments.</p>

						<h4>Object usage</h4>

						<p>Getting and setting properties on most Mayhem objects is done using <!--<a href="TODO">--><code>object.get(key)</code><!--</a>--> and <!--<a href="TODO">--><code>object.set(key, value)</code><!--</a>--> methods instead of using the normal property accessor (<code>.</code>) operator. This is necessary to support observable <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_setters_and_getters">accessor/mutator functions</a> in pre-ES5 environments, and to support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy-like behaviour</a> in pre-ES6 environments. <a href="#base-object">The Base object</a> describes how to create and use objects in Mayhem.</p>

						<h4>Object destruction</h4>

						<p>When you are done working with a class instance in Mayhem, it should always be destroyed by calling <!--<a href="TODO">--><code>object.destroy</code><!--</a>-->. Doing this ensures that any internally held references to other objects that may still be retained elsewhere are broken, and that any necessary clean-up work is completed.</p>

						<h4>Event registration</h4>

						<p>Mayhem continues the best practice established in the <a href="http://dojotoolkit.org">Dojo Toolkit</a> of returning an <!--<a href="TODO">--><code>IHandle</code><!--</a>--> object from methods that perform registrations (event listeners, method aspects, data bindings, registry entries, etc.) instead of providing symmetric add/remove APIs. This practice offers many significant benefits over symmetric APIs:</p>

						<ul>
							<li>You only need to keep a reference to the <code>IHandle</code> object, instead of needing to keep references to all arguments passed to the event registration function, or using hacks like namespaced events</li>
							<li>Anonymous functions can be used when registering event listeners that need to be removed later</li>
							<li>You only need to remember one way to remove any type of object registration (<code>handle.remove()</code>)</li>
							<li>Convenience APIs for mass-removal of registrations can be created without needing to know every possible type of registration</li>
							<li>Handles can be extended with additional context-specific APIs for modifying registrations (for example, to change the source or target of a data binding)</li>
						</ul>

						<h4>Module paths</h4>

						<p>Mayhem recommends the use of a standard set of paths for holding different object types:</p>

						<ul>
							<li><code><strong>app/models</strong></code>: This path holds all application data models.</li>
							<li><code><strong>app/routes</strong></code>: This path holds all application routes.</li>
							<li><code><strong>app/viewModels</strong></code>: This path holds all application view models.</li>
							<li><code><strong>app/views</strong></code>: This path holds all application views and templates.</li>
						</ul>

						<h4>Code conventions</h4>

						<p>Mayhem follows most normal TypeScript code conventions, with the exception that spaces are not normally placed before type definitions in order to provide better disambiguation at a glance between a type value (no space) and an object literal value (space). A <a href="https://github.com/palantir/tslint">tslint</a> profile for Mayhem, along with an up-to-date description of all code conventions, is available in the TODO <a href="https://github.com/SitePen/mayhem/blob/master/README.md">README</a> within the Mayhem repository.</p>

						<div class="a half" id="base-object"></div>
						<h3 data-id="base-object">The Base object</h3>

						<p>Within Mayhem, most objects are extended from the Observable (TODO: rename to Base) object. The Observable object provides a consistent API for getting and setting properties that allows computed properties to be created in EcmaScript 3 environments and that allows proxy-like interactions to be created in EcmaScript 5 environments.</p>

						<p>ES3-compatible computed properties can be created on Observable objects by writing protected functions with the names <code>_<i>propertyName</i>Getter</code> and <code>_<i>propertyName</i>Setter</code>. You can also declare dependencies for a computed property by adding a <code>_<i>propertyName</i>Dependencies</code> function:</p>

						<figure>
							<pre><code class="typescript">import currency = require('dojo/currency');
import Observable = require('mayhem/Observable');

class Burger extends Observable {
	get:Burger.Getters;
	set:Burger.Setters;

	protected _formattedPriceDependencies() {
		return [ 'price' ];
	}
	protected _formattedPriceGetter():string {
		return currency.format(this.get('price'));
	}
	protected _formattedPriceSetter(value:string) {
		this.set('price', currency.parse(value));
		this._notify('formattedPrice');
	}
}

export = Burger;</code></pre>
							<figcaption>ES3-compatible computed properties in Mayhem</figcaption>
						</figure>

						<p>If you don’t need to support EcmaScript 3 environments, you can use the native ES5 computed properties syntax for your computed properties instead:</p>

						<figure>
							<pre><code class="typescript">import currency = require('dojo/currency');
import Observable = require('mayhem/Observable');

class Burger extends Observable {
	get:Burger.Getters;
	set:Burger.Setters;

	protected _formattedPriceDependencies() {
		return [ 'price' ];
	}
	get formattedPrice():string {
		return currency.format(this.get('price'));
	}
	set formattedPrice(value:string) {
		this.set('price', currency.parse(value));
		this._notify('formattedPrice');
	}
}

export = Burger;</code></pre>
							<figcaption>ES5 computed properties in Mayhem</figcaption>
						</figure>

						<p>Note that the <code>formattedPrice</code> setter in both of these examples has to perform its own notification that the value has changed. This allows computed property setters to control if and when change notifications occur, and matches the behaviour of the EcmaScript 7 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe">Object.observe</a> API.</p>

						<p>When extending an Observable object, extra interfaces must be created in order to provide accurate typing information for <code>get</code> and <code>set</code> calls:</p>

						<figure>
							<pre><code class="typescript">import Observable = require('mayhem/Observable');

class Burger extends Observable {
	get:Burger.Getters;
	set:Burger.Setters;

	// …
}

module Burger {
	export interface Getters extends Observable.Getters {
		(key:'formattedPrice'):string;
		(key:'price'):number;
	}

	export interface Setters extends Observable.Setters {
		(key:'formattedPrice', value:string):void;
		(key:'price', value:number):void;
	}
}

export = Burger;</code></pre>
							<figcaption>Creating a basic Mayhem class in TypeScript</figcaption>
						</figure>

						<p>It is expected that future revisions to TypeScript will enable automatic generation of these interfaces.</p>

						<aside class="tip"><p>TODO: Not true right now. The <span class="sc">Mayhem generator</span> can create these more verbose data interfaces for you automatically. As the TypeScript language continues to mature, improved code generation and annotations will be used in order to eliminate the need to write longhand interface definitions. (One useful side-benefit of having to define getters and setters separately is that it becomes possible to type properties as being read-only or write-only within the compiler.)</p></aside>

						<h4>Setters vs observers</h4>

						<p>When creating components that extend from Observable, it’s important to distinguish between the functionality of a property setter function and the functionality of an property observer function:</p>

						<ul>
							<li>A <em>setter function</em> should be used when the way in which a property is set needs to be changed. For example, if you had a computed <code>formattedPrice</code> property that computed a human-readable price (as in the previous example), you could also have a setter function to convert a formatted price value back into a number and then set it on <code>price</code>.</li>
							<li>An <em>observer function</em> should be used when an object needs to respond to the fact that a particular property has changed. For example, if you had a computed <code>totalPrice</code> property that was based on the subtotals of items in a shopping cart, the property would never be set directly but it would update frequently as items were added and removed from the cart.</li>
						</ul>

						<p>While property setters are defined declaratively as methods of an Observable subclass, property observers are normally added to objects using the application’s <!--<a href="TODO">-->data binder<!--</a>-->. TODO: Are we keeping Observable#observe? Should we add a declarative mechanism for observing property changes on oneself?</p>
					</article>

					<article>
						<div class="a" id="application"></div>
						<h2 data-id="application">The Application subsystem</h2>

						<div class="a half" id="application-class"></div>
						<h3 data-id="application-class">Creating an application</h3>

						<p>Mayhem provides a base <!--<a href="TODO">--><code>mayhem/Application</code> class<!--</a>--> for creating new applications:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');</code></pre>

						<p>New applications are created simply by instantiating a new Application object:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application();</code></pre>

						<p>A Mayhem application can be very easily customised just by passing a configuration object to the constructor:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers'
});

log(app.get('name'));</code></pre>
							<pre class="align-bottom"><code class="javascript">'Bob’s Burgers'</code></pre>
						</div>

						<aside class="tip"><p>The <code>name</code> property of an application will be used as the title of the application in user interfaces that support titles.</p></aside>

						<p>It is also possible to create custom applications by subclassing an existing Application class. For example, the <!--<a href="TODO">--><code>mayhem/WebApplication</code> class<!--</a>--> is a subclass of <code>mayhem/Application</code> with a different default configuration suitable for writing Web applications.</p>

						<aside class="tip"><p><code>mayhem/WebApplication</code> is recommended as the default class for all applications created with the initial release of Mayhem, which focuses primarily on client-side Web apps. Future versions of Mayhem will include more Application subclasses to choose from for native mobile, server-side, and command-line apps.</p></aside>

						<p>Once the application object is ready for use, call <code>app.run()</code> to start it:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers'
});

log(app.run().then(function () {
	// started successfully
}, function (error:Error) {
	// an error occurred during start-up
}));</code></pre>
							<pre class="align-bottom"><code class="javascript">&lt;Promise></code></pre>
						</div>

						<div class="a half" id="application-components"></div>
						<h3 data-id="application-components">Application components</h3>

						<p>The Application class on its own does relatively little; its power comes in the ability to dynamically load and instantiate different <dfn>application components</dfn> that implement the individual functions necessary to create a complete application. For example, the <!--<a href="TODO">--><code>mayhem/binding/Binder</code> class<!--</a>--> is an application component that is used to perform all data binding within an application, and the <!--<a href="TODO">--><code>mayhem/ui/Master</code> class<!--</a>--> is an application component that is used to provide a user interface.</p>

						<p>The default Mayhem application components can be overridden with custom implementations. However, keep in mind that some parts of the framework that require features from application components expect them to exist at specific keys on the Application instance:</p>

						<ul>
							<li><code><strong>binder</strong></code>: An implementation of the <!--<a href="TODO">--><code>mayhem/binding/interfaces.IBinder</code><!--</a>--> interface. Provides data binding.</li>
							<li><code><strong>errorHandler</strong></code>: An implementation of the <!--<a href="TODO">--><code>mayhem/interfaces.IErrorHandler</code><!--</a>--> interface. Provides error handling for an application.</li>
							<li><code><strong>i18n</strong></code>: An implementation of the <!--<a href="TODO">--><code>mayhem/I18n</code><!--</a>--> interface. Provides internationalisation and localisation for an application.</li>
							<li><code><strong>router</strong></code>: An implementation of the <!--<a href="TODO">--><code>mayhem/routing/interfaces.IRouter</code><!--</a>--> interface. Provides navigation &amp; application state management.</li>
							<li><code><strong>scheduler</strong></code>: An implementation of the <!--<a href="TODO">--><code>mayhem/interfaces.IScheduler</code><!--</a>--> interface. Provides event scheduling.</li>
							<li><code><strong>ui</strong></code>: An implementation of the <!--<a href="TODO">--><code>mayhem/ui/Master</code><!--</a>--> interface. Provides user interface support.</li>
							<li><code><strong>user</strong></code>: An implementation of the <!--<a href="TODO">--><code>mayhem/auth/User</code><!--</a>--> object. Provides user authentication and authorization for single-user applications.</li>
						</ul>

						<p>Application components can be dynamically added to an application at runtime using the <!--<a href="TODO">--><code>components</code><!--</a>--> property of the configuration object. The configuration object gets <!--<a href="TODO">-->deep copied<!--</a>--> onto the default configuration, so default application components will continue to exist even if they are not set in the configuration object:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binder: {
		constructor: 'mayhem/binding/Binder',
		constructors: [ /* … */ ]
	},
	/* … */
	burgerStore: {
		constructor: 'app/stores/RestStore',
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<p>The default application components can be disabled by explicitly setting them to <code>null</code>:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binder: null,
		/* … */
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binder: null,
	/* … */
	burgerStore: {
		constructor: 'app/stores/RestStore',
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>Removing default application components from any of the built-in Application classes will probably cause Mayhem to break! Only use this technique to disable optional components in your own Application subclasses.</p></aside>

						<p>Deep copying also means that the properties of default application components can be tweaked without having to rewrite the entire component declaration:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: {
			useScheduler: false
		},
		/* … */
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: {
		constructor: 'mayhem/binding/Binder',
		useScheduler: false
	},
	/* … */
}</code></pre>
						</div>

						<p>Using a string value for a <code>constructor</code> property causes the Application instance to dynamically load a module matching the given string once it is started. The value of the module will be used as the constructor function to create a component.</p>

						<p>Application component constructors can also be explicitly imported and provided directly, which helps to automate <!--<a href="TODO">-->build-time dependency resolution<!--</a>-->:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');
import RestStore = require('./stores/RestStore');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: null,
		burgerStore: {
			constructor: RestStore,
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: null,
	scheduler: { /* ... */ },
	burgerStore: {
		constructor: RestStore(),
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<p>Once the application has been started, it will perform these actions:</p>

						<ol>
							<li>Freeze the <code>components</code> property so it can no longer be modified</li>
							<li>Load modules for any unloaded application components whose <code>constructor</code> properties were strings</li>
							<li>Instantiate all the application components, assigning them each to the corresponding key directly on the Application instance</li>
							<li>Call the <code>run</code> method on all application components that need to perform additional start-up actions</li>
							<li>Wait for all application components to finish starting</li>
							<li>Resolve the returned <code>run</code> promise</li>
						</ol>

						<aside class="whatAreYouCrazy"><p>Replacing any of the components attached to the Application object once the application has been started is not supported.</p></aside>

						<p>Application components are instantiated using the value of the <!--<a href="TODO">--><code>constructor</code><!--</a>--> property from the configuration object as the constructor function. The rest of the properties on the configuration object, plus an extra <code>app</code> property pointing to the Application instance, are passed as keyword arguments to the constructor:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');
import Observable = require('mayhem/Observable');
import Promise = require('mayhem/Promise');

class BurgerComponent extends Observable {
	constructor(kwArgs?:Object) {
		super(kwArgs);
		log(kwArgs);
	}

	run():Promise&lt;void> {
		// a component can do its own start-up work here,
		// and optionally return a Promise for asynchronous
		// work
		return new Promise(function (resolve:Promise.IResolver&lt;void>) {
			setTimeout(resolve, 1000);
		});
	}
}

var app = new Application({
	components: {
		burgers: {
			constructor: BurgerComponent,
			buns: [ 'regular', 'sesame' ],
			meats: [ 'beef', 'turkey', 'veggie' ],
			toppings: [ 'cheese', 'onion', 'tomato' ]
		}
	}
});

app.run().then(function () {
	log(app.get('burgers'));
});
</code></pre>
							<pre><code class="javascript">





{
	app: &lt;Application> { /* … */ },
	buns: [ /* … */ ],
	meats: [ /* … */ ],
	toppings: [ /* … */ ]
}











&lt;BurgerComponent> {
	get('app'): &lt;Application> { /* … */ },
	get('buns'): [ /* … */ ],
	get('meats'): [ /* … */ ],
	get('toppings'): [ /* … */ ]
}</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>Application components should always use their own <code>app</code> property to find their owner Application instance. Using an explicit module reference with <code>import</code> or <code>require()</code> is an anti-pattern that makes testing and reuse of application components more difficult. Application components that instantiate other objects should pass the <code>app</code> property to these objects if they also need a reference back to the application.</p></aside>

						<p>Exporting the application object makes it available for direct reference by other modules later:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

app.run();

export = app;</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>It is strongly recommended to pass the application object directly to constructors instead of having constructor modules explicitly reference the application module. For convenience, the <!--<a href="TODO">-->data modelling subsystem<!--</a>--> can be configured with a default application object based on module identifier. This is the only place where this functionality should normally be used.</p></aside>
					</article>

					<article>
						<div class="a" id="data-binding"></div>
						<h2 data-id="data-binding">Data binding subsystem</h2>

						<div class="a half" id="what-is-data-binding"></div>
						<h3 data-id="what-is-data-binding">What is data binding?</h3>

						<p>TODO: Figure here?</p>

						<p><dfn>Data binding</dfn> is a mechanism by which the value of a property on one object is kept in sync with the value of a property of another object. In other words, data binding makes it possible to have a statement <code>a.foo = 'bar'</code> also automatically execute the statement <code>b.foo = 'bar'</code>, ensuring that the properties <code>a.foo</code> and <code>b.foo</code> will always eventually contain the same value.</p>

						<p>One of the most common ways that data binding is used is to keep a user interface in sync with data from a business object. For example, given an application that displays a menu of burgers, when the name or price of one of the items on the menu changes, data binding ensures that the change is automatically reflected by the UI without requiring the programmer to notify the UI to update or re-render.</p>

						<p>Data binding is directional: it is possible to have a <dfn><em>one-way</em> binding</dfn> where only a change to the source property causes the target object to update, or a <dfn><em>two-way</em> binding</dfn> where source and target properties are kept in sync regardless of which is changed. Most data bindings are intended to keep objects in sync with each other, so the default directionality in Mayhem is two-way.</p>

						<div class="a half" id="how-to-data-bind"></div>
						<h3 data-id="how-to-data-bind">How to bind data in Mayhem</h3>

						<p>In Mayhem applications, all data binding is performed by the central <dfn>data binder</dfn> application component. By convention, this component is always created at <!--<a href="TODO">--><code>Application#binder</code><!--</a>-->. Using the data binder, it is possible to create simple bindings between two properties just by calling <!--<a href="TODO">--><code>Binder#bind</code><!--</a>-->:</p>

						<pre><code class="typescript">import BindDirection = require('mayhem/binding/BindDirection');

var binder = this.get('app').get('binder');

var a = { foo: 'bar' };
var b = { foo: null };

// `b.foo` becomes 'bar'
var handle = binder.bind({
	source: a,
	sourcePath: 'foo',
	target: b,
	targetPath: 'foo',
	direction: BindDirection.ONE_WAY
});

// `b.foo` becomes 'blah'
a.foo = 'blah';

// Removes the binding
handle.remove();</code></pre>

						<aside class="tip"><p>Much of the time, data binding in a Mayhem application will be done more concisely using the <!--<a href="TODO">-->templating system<!--</a>-->, which provides a declarative mechanism for binding data to the UI. Applications that implement their own UI components programmatically, or that want to create data bindings between non-UI objects, will use the data binder directly.</p></aside>

						<p>With the <!--<a href="TODO">-->default set of Binding constructors<!--</a>-->, the data binding system allows you to bind to arbitrarily nested properties, including those that do not exist yet, using normal dotted object syntax:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { foo: null };
var b = { foo: null };

binder.bind({
	source: a,
	sourcePath: 'foo.bar.baz',
	target: b,
	targetPath: 'foo'
});

// `b.foo` becomes 'blah'
a.foo = { bar: { baz: 'blah' } };

// `b.foo` becomes undefined
a.foo = { bar: null };</code></pre>

						<p>If you need to access a property whose name <em>contains</em> a dot, simply escape the dot with a backslash:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { 'foo.bar': 'blah' };
var b = {};

// `b.foo` becomes 'blah'
binder.bind({
	source: a,
	sourcePath: 'foo\\.bar',
	target: b,
	targetPath: 'foo'
});</code></pre>

						<p>It is also possible to more directly observe and modify a property by creating a low-level <!--<a href="TODO">--><code>Binding</code><!--</a>--> object with <!--<a href="TODO">--><code>Binder#createBinding</code><!--</a>-->. <dfn>Binding objects</dfn> are abstractions that allow us to ignore <em>how</em> and <em>where</em> a property is bound and instead focus solely on the value of the bound property:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { foo: 'bar' };

var binding = binder.createBinding&lt;string>(a, 'foo');

binding.observe(function (change:interfaces.binding.IChangeRecord&lt;string>) {
	// When the observed property changes, this function is called
	change.oldValue; // 'bar'
	change.value; // 'blah'
});

binding.get(); // 'bar'

// Causes observe callback to be called
a.foo = 'blah';</code></pre>

						<aside class="tip"><p>You can instantiate specific types of Binding objects directly by calling <code>new Binding(…)</code>, but creating bindings through the data binder allows the system to automatically choose the best type of Binding object for a given object and current environment, and offers improved efficiency by batching change notifications and delegating to existing Binding objects on properties that are bound to more than once.</p></aside>

						<div class="a half" id="binding-arrays"></div>
						<h3 data-id="binding-arrays">Binding to arrays and collections</h3>

						<p>Mayhem’s data binding system comes with additional bindings specifically for monitoring when an array or collection is changed:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var array:string[] = [];
var binding = binder.createBinding&lt;string[]>(array, '*');
binding.observe(function (change:interfaces.binding.IChangeRecord&lt;string>) {
	change.index; // 0
	change.added; // [ 'foo', 'bar' ]
	change.removed; // []
});
binding.get(); // []
array.push('foo', 'bar');
binding.get(); // [ 'foo', 'bar' ]</code></pre>

						<p>This binding is used whenever the object being bound is an array and the path matches the string <code>'*'</code>. This binding can be used as part of a longer path as well, just like all the bindings constructors in Mayhem:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { foo: [] };
var binding = binder.createBinding&lt;string[]>(a, 'foo.*');
binding.observe(function (change:interfaces.binding.IChangeRecord&lt;string>) {
	change.index; // 0
	change.added; // [ 'foo', 'bar' ]
	change.removed; // []
});
binding.get(); // []
a.foo.push('foo', 'bar');
binding.get(); // [ 'foo', 'bar' ]</code></pre>

						<aside class="whatAreYouCrazy"><p>Due to the limitations of EcmaScript 3/5, when working with arrays that are data bound, modifications must be performed using the array methods (<code>push</code>, <code>pop</code>, <code>splice</code>, etc.). Directly modifying array indices (<code>array[0] = 'foo'</code>) will not cause notifications. This limitation does not exist in environments that support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/observe">EcmaScript 7 <code>Array.observe</code></a>.</p></aside>

						<div class="a half" id="extending-binding"></div>
						<h3 data-id="extending-binding">Adding and extending bindings</h3>

						<p>As with all application components, the default data binder included with Mayhem, <!--<a href="TODO">--><code>mayhem/binding/Binder</code><!--</a>-->, can be replaced by a totally different data binder, if desired:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		binder: {
			constructor: 'app/Binder'
		}
	}
});</code></pre>

						<p>However, this is usually not necessary, since even if you need to bind to something that the default binder doesn’t understand, it is designed to be extensible through the addition of custom Binding object constructors:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		binder: {
			// Adding a new BurgerBinding type
			constructors: [ 'app/binding/BurgerBinding' ]
		}
	}
});</code></pre>

						<p>Binding constructors can also be added and removed dynamically while the application is running by calling <!--<a href="TODO">--><code>mayhem/binding/Binder#add</code><!--</a>-->:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

// Adds a new CustomBinding constructor as the top priority constructor
var handle = binder.add(CustomBinding, 0);

// Stops the CustomBinding constructor from being used by the binder
handle.remove();</code></pre>
					</article>

					<article>
						<div class="a" id="routing"></div>
						<h2 data-id="routing">Routing</h2>

						<div class="a half" id="what-is-routing"></div>
						<h3 data-id="what-is-routing">What is routing?</h3>

						<p>In many application frameworks, including Mayhem, <dfn>routing</dfn> is the primary mechanism by which an application manages its state. Usually, this state management is based on an addressable state mechanism (like a URL). (This is also sometimes called the front controller pattern.)</p>

						<p>Routing in Mayhem is performed by the <dfn>router</dfn> application component. This component is responsible for a few things:</p>

						<ul>
							<li>Reacting to changes to the address of the application (for example, from a browser’s address bar);</li>
							<li>Loading and unloading the appropriate routes for the new state; and</li>
							<li>Passing arguments parsed from the new address to the active route.</li>
						</ul>

						<p>The built-in Mayhem application routers break routing cycles down into three phases:</p>

						<ol>
							<li>Incoming requests are normalised into <!--<a href="TODO">--><code>mayhem/routing/Request</code><!--</a>--> objects. This allows the framework to handle requests identically whether they come from HTML5 history, a <code>hashchange</code> event, a Node.js HTTP server, or any other address source that can be converted to a Request object.</li>
							<li>The Request object is passed through a list of URL rules. URL rules provide the relationship between a URL and a route. In the case of an incoming request, a URL rule returns a route identifier and a map of arguments to be passed to the route object. The first URL rule that matches an incoming request wins.</li>
							<li>A route matching the route ID from the URL rule is looked up a route map. If the route exists, it is loaded, and the route arguments are passed to the route. The route then performs actions in response to the routing change (loads models, loads views, etc.).</li>
						</ol>

						<figure>
							<img src="http://placekitten.com/600/320">
							<figcaption>The default routing architecture</figcaption>
						</figure>

						<aside><p class="tip">Future versions of Mayhem will include additional ways to manage application state, including those that work well with applications that don’t have addressable states (undo/redo-based applications).</p></aside>

						<div class="a half" id="defining-routes"></div>
						<h3 data-id="defining-routes">Defining routes</h3>

						<p>A routing configuration for a very basic Web application with a single route might look like this:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		router: {
			routes: {
				menu: 'app/routes/Menu'
			}
		}
	}
});</code></pre>

						<p>When the menu route is activated—which happens when a user visits a specific URL, described below—the router will use the <code>app/routes/Menu</code> module as the constructor for the route.</p>

						<p>Routes are each given a unique string identifier so that the router can be asked to generate a URL to a specific route:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		router: {
			routes: {
				menu: 'app/routes/Menu'
			}
		}
	}
});

app.run().then(function () {
	app.get('router').createUrl('menu'); // '#!?routeId=menu'
});

</code></pre>

						<p>As demonstrated in the previous example, with no URL rules at all and using the default <!--<a href="TODO">--><code>mayhem/routing/HashRouter</code><!--</a>-->, this route would be accessible by navigating to <kbd>http://localhost/path/to/app/#!?routeId=menu</kbd>.</p>

						<p>By adding a URL rule, the URL used for a given route can be made friendlier:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		router: {
			routes: {
				menu: 'app/routes/Menu'
			},
			rules: [
				{
					routeId: 'menu',
					path: 'menu'
				}
			]
		}
	}
});</code></pre>

						<p>With this change, the menu route can now be accessed by navigating instead to <kbd>http://localhost/path/to/app/#!/menu</kbd>.</p>

						<p>Separating URL rules from the routes themselves makes it possible to also create URL rules that map to routes generically, using parameterised regular expression strings:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		router: {
			routes: {
				'menu': 'app/routes/Menu'
			},
			rules: [
				{
					path: '&lt;routeId:\\w+>'
				}
			]
		}
	}
});</code></pre>

						<p>This generic rule will work the same as the explicitly defined menu rule, but requires no new URL rules when adding additional routes to an application.</p>

						<p>It is also possible to define a default route state that will be used if a visitor navigates directly to the index page of an application:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		router: {
			defaultRoute: { routeId: 'menu' },
			routes: {
				'menu': 'app/routes/Menu'
			},
			rules: [
				{
					path: '&lt;routeId:\\w+>'
				}
			]
		}
	}
});</code></pre>

						<div class="a half" id="writing-routes"></div>
						<h3 data-id="writing-routes">Writing routes</h3>

						<p>When a route is activated after previously being inactive, its <code>beforeEnter</code> and <code>enter</code> methods are called:</p>

						<pre><code class="typescript">TODO</code></pre>

						<p>Similarly, when a route is deactivated after previously being active, its <code>beforeExit</code> and <code>exit</code> methods are called:</p>

						<pre><code class="typescript">TODO</code></pre>

						<p>The overall order of execution is <code>beforeExit</code>, <code>beforeEnter</code>, <code>exit</code>, <code>enter</code>. This pattern allows the exiting route an opportunity to pause or cancel the route change (for example, if the user needs to save changes) as well as allows the entering route to to pause or cancel the change (for example, if the user has no permission to access to the new route).</p>

						<p>All the routing lifecycle methods have the ability to pause routing to perform asynchronous operations by returning a Promise:</p>

						<pre><code class="typescript">TODO</code></pre>

						<p>Rejecting a returned promise, or throwing an error, will cause the application’s <code>errorHandler</code> to be invoked unless the thrown error is a <code>dojo/promise/CancelError</code>, in which case the routing action will simply be cancelled. Attempting to navigate to another route while an existing route transition is underway will cause the existing transition to be cancelled.</p>

						<p>If a route is already active and the router detects a state change that will not deactivate the active route, the <!--<a href="TODO">--><code>update</code><!--</a>--> method will be called on the active route to notify it of the changed route parameters.</p>

						<aside class="tip"><p>Errors are used instead of passing an event with a <code>preventDefault</code> method, or using a boolean return value, in order to provide a standard way for routes to give additional details to the router or other parts of the application about why a routing change was prevented.</p></aside>
					</article>

					<article>
						<div class="a" id="views"></div>
						<h2 data-id="views">Views</h2>

						<div class="a half" id="mayhem-views"></div>
						<h3 data-id="mayhem-views">How views work</h3>

						<p>The view subsystem in Mayhem is different from most other Web application frameworks (Ember, Polymer, Angular, React, etc.) because it fully abstracts the platform UI (i.e. the DOM). This means that unless you are creating a <!--<a href="TODO">-->custom platform widget<!--</a>-->, you never touch the DOM directly. This approach requires thinking slightly differently about how user interfaces are created, but it allows you to do several exceptional things:</p>

						<ul>
							<li>Your application can use native UI controls (i.e. real iOS and Android widgets) with few or no changes</li>
							<li>Your application can run from a Web Worker process, ensuring the UI thread is never blocked</li>
							<li>You don’t need to understand complex tree diffing mechanisms like Virtual DOM, since monolithic <code>render</code> methods that rebuild the entire view when something changes aren’t used</li>
							<li>You don’t have to worry about platform bugs or missing features (like Pointer Events), since they can be handled by Mayhem’s UI abstraction layer</li>
						</ul>

						<aside class="tip"><p>Although your code won’t interact with the DOM directly, Mayhem comes with a familiar, HTML-like templating language that makes it easy for Web developers to start creating UIs for Web-only applications using a familiar syntax and more direct control over the DOM.</p></aside>

						<p>Views in Mayhem are composed of multiple widgets and other views. <dfn>Widgets</dfn> are views that represent reusable UI components—text labels, input controls, lists, grids, and so on. Widgets and views can be created using one of three approaches:</p>

						<ul>
							<li><strong>Declarative approach</strong>: using <!--<a href="TODO">-->view templating<!--</a>--> to generate a view from markup</li>
							<li><strong>Programmatic approach</strong>: using inheritance to extend the base <!--<a href="TODO">--><code>Widget</code><!--</a>--> class</li>
							<li><strong>Hybrid approach</strong>: extending a View generated declaratively and adding extra features programmatically</li>
						</ul>

						<p>The most common approach for simple applications is to create views declaratively. These are called <dfn>templated views</dfn>:</p>

						<pre><code class="html">&lt;h1>{app.name}&lt;/h1>

&lt;p>What kind of burger do you want?&lt;/p>

TODO: This does not work with dstore collections
&lt;if condition={app.burgers.length}>
	&lt;ul>
		&lt;for each={app.burgers} as="burger">
			&lt;li>
				{burger.name} - {burger.formattedPrice}
			&lt;/li>
		&lt;/for>
	&lt;/ul>
&lt;else>
	Sorry, we have no burgers
&lt;/if></code></pre>

						<p>The <!--<a href="TODO">-->HTML templating engine<!--</a>--> is implemented as an <a href="http://dojotoolkit.org/reference-guide/1.10/loader/amd.html#plugins">AMD loader plugin</a>, so loading a templated view is straightforward in most cases:</p>

						<pre><code class="typescript">import WebApplication = require('mayhem/WebApplication');

var app = new WebApplication({
	name: 'Bob’s Burgers',
	burgers: [
		{ name: 'New Bacon-ings', formattedPrice: '$12.50' },
		{ name: 'Pepper Don’t Preach Burger', formattedPrice: '$10.50' },
		{ name: 'Totally Radish Burger', formattedPrice: '$9.25' },
		{ name: 'Chard To A Crisp Burger', formattedPrice: '$9.00' },
		{ name: 'Beets Me Burger', formattedPrice: '$10.00' }
	],
	components: {
		ui: {
			view: 'mayhem/templating/html!app/views/Master.html'
		}
	}
});

app.run();</code></pre>

						<p>The <a href="#view-templating">view templating</a> section describes the templating language in greater detail.</p>

						<div class="a half" id="view-templating"></div>
						<h3 data-id="view-templating">View templating</h3>

						<p>The default templating system in Mayhem is an extension of HTML that overlays data binding, conditionals, loops, custom elements, and other basic features onto the language. <a href="#how-to-data-bind">Data binding paths</a> are placed inside curly brackets (<code>{path}</code> for one-way binding and <code>{{path}}</code> for two-way binding) and bind to the <code>model</code> object (TODO: Should it be the code-behind view object instead? otherwise we’re restricted.) associated with the view:</p>

						<pre><code class="html">{name}</code></pre>
						<pre><code class="typescript">view.set('model', { name: 'foo' });</code></pre>

						<p>Outputs:</p>

						<pre><code class="html">foo</code></pre>

						<p>Using a widget in a view is as simple as using the <code>&lt;widget></code> tag:</p>

						<pre><code class="html">&lt;widget is="mayhem/ui/Label" text={foo}>&lt;/widget></code></pre>

						<p>The value of the <code>is</code> attribute must be a module ID that resolves to a view constructor.</p>

						<p>Mayhem’s HTML templating engine also allows widgets to be registered as custom elements within individual templates, which is useful when the same widget is used multiple times within a template:</p>

						<pre><code class="html">&lt;alias tag="label" to="mayhem/ui/Label">
&lt;label text={foo}>&lt;/label></code></pre>

						<p>This example is equivalent to the previous example, except the <code>&lt;label></code> tag has been aliased to the <code>mayhem/ui/Label</code> widget.</p>

						<p>Because aliases are defined only for the specific template in which they appear, there is no chance of aliases conflicting with aliases from other templates. This is different from Web components, which require custom elements to be registered on the parent document and can cause conflicts when multiple applications run on the same page.</p>

						<p>Mayhem’s HTML templating includes some extra, special tags for conditionals, loops, and Promise handling:</p>

						<ul>
							<li><strong><code>&lt;if></code>, <code>&lt;elseif></code>, and <code>&lt;else></code></strong>: Allows content to be conditionally displayed. Internally, creates an instance of the <!--<a href="TODO">--><code>mayhem/templating/html/ui/Conditional</code><!--</a>--> widget.</li>
							<li><strong><code>&lt;when></code>, <code>&lt;pending></code>, and <code>&lt;rejected></code></strong>: Allows different content to be displayed while a Promise is being resolved. Internally, creates an instance of the <!--<a href="TODO">--><code>mayhem/templating/html/ui/Promise</code><!--</a>--> widget.</li>
							<li><strong><code>&lt;for></code></strong>: Allows simple iteration over an array or <a href="https://github.com/SitePen/dstore/blob/master/docs/Collection.md">Collection</a>. Internally, creates an instance of the <!--<a href="TODO">--><code>mayhem/templating/html/ui/Iterator</code><!--</a>--> widget.</li>
						</ul>

						<h4>Conditional display</h4>

						<p>TODO: It would be nice to eliminate the “condition=” part</p>
						<pre><code class="html">&lt;if condition={foo}>
	Has a foo
&lt;elseif condition={bar}>
	Has a bar
&lt;else>
	No foo, no bar
&lt;/if></code></pre>

						<aside class="tip"><p>This mechanism is designed only to show and hide blocks of widgets. Conditional attributes should be handled by creating a specific <!--<a href="TODO">-->view–model<!--</a>--> and binding the attribute to a <!--<a href="TODO">-->computed property<!--</a>--> on the model.</p></aside>

						<h4>Promise handling</h4>

						<pre><code class="html">&lt;when value={foo} as="fooValue">
	foo is resolved to {fooValue}
&lt;pending>
	Please wait for foo
&lt;rejected as="fooError">
	foo was rejected because {fooError.message}
&lt;/when></code></pre>

						<h4>Iterator</h4>

						<pre><code class="html">&lt;for each={foo} as="item">
	{item.name}
&lt;/for></code></pre>

						<aside class="tip"><p>The iterator widget is a dumb widget that will always attempt to fetch and render all items from an array or collection. Use a <!--<a href="TODO">--><code>mayhem/ui/ListView</code><!--</a>--> or <!--<a href="TODO">--><code>mayhem/ui/GridView</code><!--</a>--> when you need to render large collections with full lazy-loading and resource management. TODO: This is not true now, but should be, since dgrid can’t do MultiNodeWidget.</p></aside>

						<div class="a half" id="cross-platform-views"></div>
						<h3 data-id="cross-platform-views">Using cross-platform views</h3>

						<p>Mayhem’s view system is designed so that the underlying rendering platform (DOM, iOS, Android, Node.js streams, etc.) is never exposed to an application under normal use. This means that Mayhem applications can be written to run seamlessly across multiple platforms, using native UI controls, without having to rewrite the application in a different language, and without having to emulate the UI features of the target platform.</p>

						<p>In order to create a cross-platform application, it’s necessary to use the standard set of widgets.</p>

						<div class="a half" id="event-system"></div>
						<h3 data-id="event-system">The event system</h3>

						<p>In addition to displaying information to a user interface, the view system is also responsible for receiving input from a user interface that can be used to execute functions within an application in response to interaction. To do this, Mayhem provides an event abstraction system that normalises input from different view implementations into a standard event model.</p>

						<p>The standard event model in Mayhem translates all pointer inputs (mouse, pen, touch, etc.) into standard <!--<a href="TODO">--><code>PointerEvent</code><!--</a>--> objects that closely match the W3C Pointer Events API, and keyboard events into standard <!--<a href="TODO">--><code>KeyboardEvent</code><!--</a>--> objects that closely match the latest DOM 3 Events API:</p>

						<pre><code class="typescript">TODO: example</code></pre>

						<p>It is possible to easily create custom events, such as gestures, using <!--<a href="TODO">-->extension events<!--</a>--> that listen for lower-level events and then dispatch the custom events when the custom event’s criteria are satisfied:</p>

						<pre><code class="typescript">TODO: example</code></pre>

						<div class="a half" id="custom-platform-widgets"></div>
						<h3 data-id="custom-platform-widgets">Custom platform widgets</h3>

						<p>When creating custom platform widgets, the <code>_render</code> method can be used to generate native UI controls knowing that all initial properties from the <code>kwArgs</code> object have been set. This method will only ever be invoked <em>once</em>. There is no guarantee about exactly when this method will be invoked, except that it will always be after all <code>kwArgs</code> properties have been set but before the widget is attached to the view tree.</p>

						<p>Custom widgets should do their best to only update while their <code>isAttached</code> property is <code>true</code>. When <code>isAttached</code> is <code>false</code>, the widget is not attached to the view tree, and UI updates performed in this condition will never be seen by a user. Widgets should not use the <code>detach</code> method as an indicator to halt operations since this method is used a widget is simply moved from one part of the UI to another.</p>

						<p>TODO: There should probably be rendering lifecycle methods to avoid <code>isAttached</code> churn? Data binding loop, view read loop, view write loop.</p>
					</article>


					<article>
						<div class="a" id="collections"></div>
						<h2 data-id="collections">Collections</h2>

						<div class="a half" id="what-is-collection"></div>
						<h3 data-id="what-is-collection">Collections basics</h3>

						<p>TODO: Figure of data layer, model | collection | store | HTTP | server.</p>

						<p>Like arrays, collections hold sets of data, but do so with an API that’s suitable for working with data that comes from asynchronous data sources, like remote servers or databases. Mayhem uses <a href="http://dstorejs.io/">dstore</a> to provide a robust collections API for use with Mayhem applications.</p>

						<p>Collections in Mayhem are generated by first creating a <a href="https://github.com/SitePen/dstore/blob/master/Store.js"><code>dstore.Store</code></a> data store, then executing <code>filter</code> and <code>sort</code> calls in order to create a collection representing a subset of the data in the store:</p>

						<pre><code class="typescript">import RestStore = require('app/stores/RestStore');
import Burger = require('app/models/Burger');

var burgers = new RestStore({ target: '/rest/burgers/' });
burgers.filter({ hasCheese: true }).sort('name').fetch().then(function (cheeseburgers:Burger[]) {
	// just the cheeseburgers, sorted ascending by name
});</code></pre>

						<p>Data stores can also be used directly as collections in order to retrieve all data from the store:</p>

						<pre><code class="typescript">import RestStore = require('app/stores/RestStore');
import Burger = require('app/models/Burger');

var burgers = new RestStore({ Model: Burger, target: '/rest/burgers/' });
burgers.fetch().then(function (allBurgers:Burger[]) {
	// all the burgers
});</code></pre>

						<p>Collections in Mayhem support fetch ranges, so you can request records in pages instead of needing to inefficiently retrieve all data at once:</p>

						<pre><code class="typescript">import RestStore = require('app/stores/RestStore');
import Burger = require('app/models/Burger');

var burgers = new RestStore({ Model: Burger, target: '/rest/burgers/' });
burgers.fetchRange({ start: 0, end: 10 }).then(function (firstTenBurgers:Burger[]) {
	// the first ten burgers
});</code></pre>

						<p>Different stores may use different <code>fetchRange</code> arguments; for example, stores based on technologies like DynamoDB, which don’t support integral paging, may require an exclusive start key to be passed instead.</p>

						<aside class="tip"><p>Data-driven components within Mayhem like <!--<a href="TODO">--><code>mayhem/ui/ListView</code><!--</a>--> will automatically manage fetching the correct amount of data for display when passed a collection, so you will only need to do this when interacting with collections in your own code.</p></aside>

						<p>Collections also provide a <code>forEach</code> convenience method for asynchronously iterating over the items in a collection without requiring extra <code>fetch</code> boilerplate:</p>

						<pre><code class="typescript">import RestStore = require('app/stores/RestStore');
import Burger = require('app/models/Burger');

var burgers = new RestStore({ Model: Burger, target: '/rest/burgers/' });
burgers.forEach(function (burger:Burger[]) {
	// called once for each burger in the store, as they become available
});</code></pre>

						<aside class="whatAreYouCrazy"><p><code>Collection#forEach</code> is an asynchronous method.</p></aside>

						<p>Users familiar with SQL databases can map most of the functionality of a Mayhem/dstore Collection directly back to concepts in SQL:</p>

						<table>
							<tr>
								<th>Mayhem / dstore</th>
								<th>SQL</th>
							</tr>
							<tr>
								<td>Store</td>
								<td>Table</td>
							</tr>
							<tr>
								<td>Collection</td>
								<td><a href="https://en.wikipedia.org/wiki/View_%28SQL%29">View</a></td>
							</tr>
							<tr>
								<td><code>Collection#filter</code></td>
								<td><code>WHERE</code></td>
							</tr>
							<tr>
								<td><code>Collection#sort</code></td>
								<td><code>ORDER BY</code></td>
							</tr>
							<tr>
								<td><code>Collection#fetchRange</code></td>
								<td><code>LIMIT</code>/<code>OFFSET</code>/<code>FETCH FIRST</code></td>
							</tr>
						</table>

						<div class="a half" id="creating-collections"></div>
						<h3 data-id="creating-collections">Creating collections</h3>

						<p>TODO</p>
					</article>

					<article>
						<div class="a" id="data-models"></div>
						<h2 data-id="data-models">Data models</h2>

						<div class="a half" id="mayhem-model"></div>
						<h3 data-id="mayhem-model">Data model basics</h3>

						<p>TODO: Figure here?</p>

						<p>A model is an object that provides business logic and data for an application (as opposed to a view–model which provides <em>view-specific</em> logic and data). For developers that have worked with databases but are unfamiliar with models, a model can be thought of as an object representing one record in a database table, where the properties of the model correspond to columns in the database.For example, we might create a Burger model corresponding to a type of burger on our menu:</p>

						<pre><code class="typescript">import currency = require('dojo/currency');
import Model = require('mayhem/data/Model');

class Burger extends Model {
	get:Burger.Getters;
	set:Burger.Setters;

	_formattedPriceGetter():string {
		return currency.format(this.get('price') / 100);
	}
	_formattedPriceSetter(value:string) {
		this.set('price', currency.parse(value) / 100);
	}

	_initialize() {
		super._initialize();
		this.set('name', 'Untitled burger');
		this.set('ingredients', []);
	}
}

module Burger {
	export interface Getters {
		(key:'name'):string;
		(key:'formattedPrice'):string;
		(key:'ingredients'):string[];
		(key:'price'):number;
	}

	export interface Setters {
		(key:'name', value:string):void;
		(key:'formattedPrice'):string;
		(key:'price', value:number):void;
	}
}

export = Burger;</code></pre>

						<p>In Mayhem, models are normally created as subclasses of <!--<a href="TODO">--><code>mayhem/data/Model</code><!--</a>-->. Models that are designed to be saved and retrieved from a <!--<a href="TODO">-->data store<!--</a>--> are subclasses of <!--<a href="TODO">--><code>mayhem/data/PersistentModel</code><!--</a>-->.</p>

						<div class="a half" id="tracking-model-changes"></div>
						<h3 data-id="tracking-model-changes">Tracking model changes</h3>

						<p>Mayhem’s Models track the “dirtiness” of model properties, so you can determine whether or not the properties of a model have been changed and revert those changes before they are permanently committed:</p>

						<pre><code class="typescript">var burger = new Burger({
	name: 'Kales From The Crypt Burger',
	formattedPrice: '$5.95'
});

log(burger.get('isDirty')); // false
burger.set('formattedPrice', '$10.50');

log(burger.get('isDirty')); // true
log(burger.get('formattedPrice')); // '$10.50'

burger.revert();

log(burger.get('isDirty')); // false
log(burger.get('formattedPrice')); // '$5.95'

burger.set('formattedPrice', '$10.50');

burger.commit();

log(burger.get('isDirty')); // false
log(burger.get('formattedPrice')); // '$10.50'</code></pre>

						<div class="a half" id="scenarios"></div>
						<h3 data-id="scenarios">Scenarios</h3>

						<p>TODO Discuss scenarios</p>

						<div class="a half" id="validation"></div>
						<h3 data-id="validation">Validation</h3>

						<p>Once a model is populated with data from a user, it’s usually necessary to validate that the data is actually valid. Validation rules for Mayhem models are declared by providing a validators key on the model that returns a map of property keys to validators:</p>

						<pre><code class="typescript">import RequiredValidator = require('mayhem/validation/RequiredValidator');
import StringValidator = require('mayhem/validation/StringValidator');
import NumberValidator = require('mayhem/validation/NumberValidator');

class Burger {
	// …

	_validatorsGetter() {
		return {
			name: [
				new RequiredValidator(),
				new StringValidator({ maxLength: 40 })
			],
			price: [
				new RequiredValidator(),
				new NumberValidator({ min: 500 })
			]
		};
	}
}

export = Burger;</code></pre>

						<p>Validation rules can be restricted to specific scenarios by specifying which scenarios are valid for a particular validator:</p>

						<pre><code class="typescript">import Model = require('mayhem/data/PersistentModel');
import RequiredValidator = require('mayhem/validation/RequiredValidator');

class BurgerUser extends PersistentModel {
	// …

	_validatorsGetter() {
		return {
			email: [
				new RequiredValidator()
			],
			confirmEmail: [
				// TODO: Rename 'scenarios' to 'on' in code
				new RequiredValidator({ on: [ 'insert' ] })
			]
		};
	}
}

export = BurgerUser;</code></pre>

						<p>In this case, the <code>confirmEmail</code> property only needs to be filled out when the <code>scenario</code> property of the model is set to <code>'insert'</code>. If the scenario is changed to something else (like <code>'update'</code>), the validator will no longer be applied.</p>

						<p>TODO: Describe custom validators and asynchronous validators</p>

						<div class="a half" id="persisting-data"></div>
						<h3 data-id="persisting-data">Persisting data</h3>

						<p>In order to persist data models across page loads, a data model should extend from the <!--<a href="TODO">--><code>mayhem/data/PersistentModel</code><!--</a>--> class. The <code>PersistentModel</code> class TODO</p>
					</article>

					<article>
						<div class="a" id="i18n"></div>
						<h2 data-id="i18n">Internationalisation</h2>

						<div class="a half" id="i18n-object"></div>
						<h3 data-id="i18n-object">The I18n object</h3>

						<p>The I18n application component provides all the necessary functionality for internationalising Mayhem applications.</p>

						<p>By default, the locale used by the I18n component is taken from the current environment, using <code>navigator.language</code> in browsers and <code>process.env.LANG</code> in Node.js. The locale can be overridden at startup by setting the <code>locale</code> property, or at runtime by calling <!--<a href="TODO">--><code>I18n#switchToLocale</code><!--</a>-->:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		i18n: {
			locale: 'en-us'
		}
	}
});

app.run();</code></pre>

						<div class="a half" id="i18n-messages"></div>
						<h3 data-id="i18n-messages">Translating messages</h3>

						<p>Mayhem uses the standard <a href="http://userguide.icu-project.org/formatparse/messages">Unicode MessageFormat</a> format to provide accurate translation of plurals, gender, and other features that vary across locales:</p>

						<pre><code class="messageformat">{GENDER, select,
    male {He}
  female {She}
   other {They}
} found {NUM_RESULTS, plural,
            one {1 result}
          other {# results}
        } in {NUM_CATEGORIES, plural,
                  one {1 category}
                other {# categories}
			}.</code></pre>

						<p>Translation dictionaries are created by writing <!--<a href="TODO">-->NLS bundles<!--</a>-->. NLS bundles are simply modules placed inside an <code>nls</code> directory, separated by locale:</p>

						<pre>app/
	nls/
		myBundle.ts
		en/
			myBundle.ts
		es/
			myBundle.ts</pre>

						<p>The root NLS bundle (<code>app/nls/myBundle</code> in this example) defines the list of available translation locales for that bundle. It also provides a set of default backup translations for locales without translations. The list of supported locales are simply boolean values on the exported object, whereas the default translations are provided on the <code>root</code> property:</p>

						<pre><code class="typescript">// in app/nls/myBundle.ts

// Available locales, `en` and `es`
export var en = true;
export var es = true;

// Default translations for locales other than `en` and `es`
export var root = {
	greeting: 'Hello, {NAME}!',
	orderBurgers: `Order {NUM_BURGERS, plural,
	                       zero {zero burgers},
	                        one {one burger},
	                      other {# burgers}
	                     }`
};</code></pre>

						<p>Locale-specific bundles simply export each message directly:</p>

						<pre><code class="typescript">// in app/nls/es/myBundle.ts
export var greeting = 'Hola, {NAME}!';
export var orderBurders = `Pedir {NUM_BURGERS, plural,
                                    zero {cero hamburguesas},
                                     one {una hamburguesa},
                                   other {# hamburguesas}
                                 }`;</code></pre>

						<p>To load an NLS bundle into I18n at runtime, call <!--<a href="TODO">--><code>I18n#loadBundle</code><!--</a>-->, passing the root bundle’s module ID. It is also possible to preload message bundles at startup by setting the <code>preload</code> property to an array of module IDs:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		i18n: {
			locale: 'en-us',
			preload: [ 'app/nls/myBundle' ]
		}
	}
});

app.run();</code></pre>

						<p>When a bundle is loaded, its values will be compiled into functions (if they are not already functions) and added to the existing set of messages. To use a message, call the formatter from the <code>messages</code> key, passing any arguments necessary for the translation to be completed successfully:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		i18n: {
			locale: 'en-us',
			preload: [ 'app/nls/myBundle' ]
		}
	}
});

app.run().then(function () {
	app.get('i18n').get('messages')['orderBurgers']({ NUM_BURGERS: 1 }); // 'Order one burger'
});</code></pre>

						<aside class="tip"><p>While it may look like you’re loading a lot of modules when writing translations, by performing a build, you can combine all your NLS bundles into built bundles that require only one HTTP request to load all translations for a locale.</p></aside>

						<div class="a half" id="i18n-numbers-dates"></div>
						<h3 data-id="i18n-numbers-dates">Numbers &amp; dates</h3>

						<p>The I18n object also provides currency, number, and date formatting/parsing functionality, built on top of the Dojo date &amp; number libraries:</p>

						<table>
							<tr>
								<th>Type</th>
								<th>Parsing function</th>
								<th>Formatting function</th>
							</tr>
							<tr>
								<td>Date/time</td>
								<td><code>I18n#parseDate(string, <a href="http://dojotoolkit.org/api/?qs=1.10/dojo/date/locale.__FormatOptions">options</a>)</code></td>
								<td><code>I18n#formatDate(date, <a href="http://dojotoolkit.org/api/?qs=1.10/dojo/date/locale.__FormatOptions">options</a>)</code></td>
							</tr>
							<tr>
								<td>Currency</td>
								<td><code>I18n#parseCurrency(string, <a href="http://dojotoolkit.org/api/?qs=1.10/dojo/currency.__ParseOptions">options</a>)</code></td>
								<td><code>I18n#formatCurrency(number, <a href="http://dojotoolkit.org/api/?qs=1.10/dojo/currency.__FormatOptions">options</a>)</code></td>
							</tr>
							<tr>
								<td>Number</td>
								<td><code>I18n#parseNumber(string, <a href="http://dojotoolkit.org/api/?qs=1.10/dojo/number.__ParseOptions">options</a>)</code></td>
								<td><code>I18n#formatNumber(number, <a href="http://dojotoolkit.org/api/?qs=1.10/dojo/number.__FormatOptions">options</a>)</code></td>
							</tr>
						</table>

						<p>Dates, currency, and numbers will be formatted/parsed according to the currently defined locale, using data from the <a href="http://cldr.unicode.org/">Unicode Common Locale Data Repository</a>.</p>
					</article>

					<article>
						<div class="a" id="security"></div>
						<h2 data-id="security">Security</h2>

						<div class="a half" id="user-object"></div>
						<h3 data-id="user-object">The User object</h3>

						<p>The main application component responsible for handling authentication and authorization within a Mayhem application is the User object. This object represents the identity of the current user and encompasses all functionality related to user access control. Using the User object, you can:</p>

						<ul>
							<li>Log a user in and out (<!--<a href="TODO">--><code>User#login</code><!--</a>--> and <!--<a href="TODO">--><code>User#logout</code><!--</a>-->)</li>
							<li>Check whether a user is logged in (<!--<a href="TODO">--><code>User#isAuthenticated</code><!--</a>-->)</li>
							<li>Check whether a user has access to perform an operation (<!--<a href="TODO">--><code>User#checkAccess</code><!--</a>-->)</li>
							<li>Get and set other arbitrary data about the current user (name, email address, etc.)</li>
						</ul>

						<p>When creating an application with access control, the User object needs to be subclassed to add the correct authentication method for your application:</p>

						<pre><code class="typescript">import request = require('dojo/request');
import User = require('mayhem/auth/User');
import WebApplication = require('mayhem/WebApplication');

class BurgerUser extends User {
	protected _authenticate(kwArgs:{ username:string; password:string; }):Promise&lt;{}> {
		return request('/authenticate/', {
			data: JSON.stringify(kwArgs)
		}).then(function (result) {
			// If authentication fails, the promise should be
			// rejected with an error describing the reason for
			// failure
			if (result.error) {
				throw new Error(result.error);
			}

			// If authentication succeeds, the object resolved
			// by the promise will be available to the rest
			// of the application at `user.state`. This can
			// contain any arbitrary information, like a friendly
			// name for the user to display in the UI, lists of
			// valid roles that can be used by `checkAccess`, or
			// anything else your application needs.
			return result.state;
		});
	}
}

var app = new Application({
	user: new BurgerUser()
});

app.run();</code></pre>

						<div class="a half" id="rbac"></div>
						<h3 data-id="rbac">Role-based access control (RBAC)</h3>

						<p>Mayhem uses role-based access control to authorize users to perform certain actions within an application. RBAC works by describing a set of <i>permissions</i> that the application checks when performing certain actions, then granting those permissions to different <i>roles</i> that can be assigned to users.</p>

						<p>In Mayhem, a <dfn>permission</dfn> is simply a unique string, like <code>'view'</code> or <code>'update'</code>, that describes the permission to be granted. Permissions are granted to roles by calling <!--<a href="TODO">--><code>Role#can</code><!--</a>-->, passing optional business logic that can provide additional runtime restrictions on whether or not the permission is granted:</p>

						<pre><code class="typescript">// TODO: Preliminary APIs, subject to change, no implementation
// Provide the list of actions, and definitions for each action
// that can be displayed in an administrative control panel
authManager.addPermission('viewBurger');
authManager.addPermission('createBurger');
authManager.addPermission('updateBurger');
authManager.addPermission('deleteBurger');

// Guests can only view things
var guest = new Role('guest');
guest.can('viewBurger');

var normal = new Role('normal');

// Normal users can do what guests do…
normal.inheritFrom(guest);

// …plus create new burgers…
normal.can('createBurger');

// …plus update or delete burgers, but only burgers that they created
normal.can([ 'updateBurger', 'deleteBurger' ], function (burger:{ creatorId:string; }) {
	return burger.creatorId === this.get('app').get('user').get('id');
});

// Administrators can do everything to everything
var admin = new Role('admin');
admin.can('viewBurger', 'createBurger', 'updateBurger', 'deleteBurger');

// Once all the roles are created they need to be added to the list of available roles
authManager.addRoles([ guest, user, admin ]);</code></pre>

						<p>Once the role hierarchy is established, roles can be assigned and unassigned from users by calling <code>User#addRole</code> and <code>User#removeRole</code>:</p>

						<pre><code class="typescript">// Downgrade a user from admin to normal user
user.removeRole('admin');
user.addRole('normal');</code></pre>

						<p>TODO: User object may not be the best place to hold all of the authorisation stuff, we might want to create a second component to do some of this, since there needs to be a way to bulk change &amp; persist to a remote server/database, like an auth manager as noted above. In such a case adding/removing roles would be done within the auth manager instead of on the user object itself.</p>

						<p>It is possible to assign a user multiple roles if this makes sense for your role system.</p>

						<p>Finally, in application code, call <!--<a href="TODO">--><code>User#checkAccess</code><!--</a>--> to determine whether or not the user has been granted permission to a particular activity:</p>

						<pre><code class="typescript">// TODO: Improve this example to give surrounding Route code
return this.get('app').get('user').checkAccess('updateBurger', burger)
	.then(function (isAllowed:boolean) {
		if (!isAllowed) {
			throw new Error('Permission denied');
		}
	});</code></pre>
					</article>

					<article>
						<div class="a" id="testing"></div>
						<h2 data-id="testing">Testing</h2>

						<div class="a half" id="testing-apps"></div>
						<h3 data-id="testing-apps">Testing Mayhem apps</h3>

						<p>Mayhem uses the <a href="http://theintern.io">Intern testing framework</a> to test its own code and comes bundled with TypeScript definition files so applications can easily write tests in TypeScript as well. Generating an application using the Mayhem generator will provide you with a pre-created set of tests, test configuration, and Grunt task to match the example application.</p>

						<p>One of the primary reasons that Application objects are passed to all instances throughout a Mayhem application is to enable simple dependency injection when testing classes in isolation. Passing the application object in this manner allows tests to easily provide mock application objects to each component.</p>

						<p>TODO: Add more info here.</p>
					</article>

					<article>
						<div class="a" id="optimising"></div>
						<h2 data-id="optimising">Optimising</h2>

						<div class="a half" id="creating-builds"></div>
						<h3 data-id="creating-builds">Creating builds</h3>

						<p>Mayhem is built on top of the Dojo Toolkit and so comes bundled with a complete code optimiser that enables highly optimised builds to be created with minimal effort. Generating an application using the Mayhem generator will provide you with a pre-created build profile and Grunt build task to match the example application.</p>

						<p>To significantly reduce the number of dependencies that you need to explicitly put in your build profile, prefer to load your dependencies using explicit <code>import</code> calls instead of using string constructors for dependency injection:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	components: {
		foo: {
			// don't do this
			constructor: 'app/Foo'
		}
	}
});</code></pre>

						<pre><code class="typescript">import Application = require('mayhem/Application');
import Foo = require('./Foo');

var app = new Application({
	components: {
		foo: {
			// do this instead
			constructor: Foo
		}
	}
});</code></pre>
					</article>

					<article>
						<div class="a" id="community"></div>
						<h2 data-id="community">Community</h2>

						<div class="a half" id="getting-help"></div>
						<h3 data-id="getting-help">Getting help</h3>

						<p>The Mayhem team wants to help people like you write applications more quickly and easily than ever before. As such, we offer two different ways you can get help with Mayhem:</p>

						<h4>Community support</h4>

						<p>The Mayhem community is available to assist you with basic questions, advice, and general guidance. There are two primary ways to get community support:</p>

						<ul>
							<li>Post on Stack Overflow using the tag <a href="http://stackoverflow.com/questions/ask?tags=mayhem">[mayhem]</a>. Please make sure to follow the <a href="http://stackoverflow.com/help/how-to-ask">Stack Overflow guidelines</a> when asking your question in order to have the greatest chance of receiving a response!</li>
							<li>Join us on IRC at <a href="irc://irc.freenode.net/mayhem">#mayhem on Freenode</a>. Please make sure to follow the <a href="https://rurounijones.github.io/blog/2009/03/17/how-to-ask-for-help-on-irc/">How to Ask for Help on IRC</a> when asking your question in order to have the greatest chance of receiving a response!</li>
						</ul>

						<h4>Commercial support</h4>

						<p>Some problems are too complicated, specific, time-sensitive, or confidential to be solved through free community support. In these cases, the creators of Mayhem, SitePen, offer <a href="http://www.sitepen.com/support/index.html">commercial support services</a> for you or your company. Commercial support has several advantages over community support:</p>

						<ul>
							<li>Guaranteed response</li>
							<li>24 hours maximum response time</li>
							<li>Priority bug fix and enhancement requests</li>
							<li>Total confidentiality for your next big idea</li>
							<li>Provides direct financial support for ongoing development of Mayhem</li>
						</ul>

						<p>If you aren’t sure if commercial support is right for you, we’re happy to take a few minutes to talk through your needs in greater detail. <a href="https://www.sitepen.com/site/contact.html">Get in touch</a> to schedule a time!</p>

						<div class="a half" id="contributing"></div>
						<h3 data-id="contributing">Contributing</h3>

						<p>We’re always excited to receive contributions from the community. If you think you’ve discovered a bug, want to submit a patch, or would like to request a new feature, take a look at our <a href="https://github.com/SitePen/mayhem/blob/master/CONTRIBUTING.md">contribution guidelines on GitHub</a> to learn how you can contribute.</p>
					</article>
				</main>
			</div>
		</div>
		<script src="css/highlight.pack.js"></script>
		<script src="css/main.js"></script>
	</body>
</html>
