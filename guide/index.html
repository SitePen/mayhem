<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<title>Mayhem ◇ User guide</title>
		<link rel="stylesheet" href="css/main.css">
		<script>(function () {
			var test = document.createElement('b');
			for (var prefix in { '': 1, '-webkit-': 1 }) {
				var position = prefix + 'sticky';
				test.style.position = position;
				if (test.style.position === position) {
					return;
				}
			}
			document.documentElement.classList.add('no-sticky');
		})();</script>
	</head>
	<body>
		<span role="button" id="showMenu" class="icon-menu"
			aria-controls="tableOfContents"
			aria-expanded="false"
			tabindex="0"
			title="Table of contents">Menu</span>
		<header class="header">
			<div class="wrapper">
				<div class="preTitle">
					<a class="logo" href=""><img alt="Mayhem logo"></a>
					<nav id="mainMenu">
						<ul>
							<li><a href="">About</a></li>
							<li><a href=""><span class="hide-680">User </span>guide</a></li>
							<li><a href="">API<span class="hide-680"> reference</span></a></li>
							<li><a href="">Community</a></li>
						</ul>
					</nav>
				</div>
				<div id="initialScrollPoint">
					<label class="search" role="search">
						<input type="text">
						<span class="icon-search"></span>
					</label>
					<h1 class="title"><span class="bold">Mayhem</span> user guide</h1>
				</div>
				<script>(function () {
					if (window.scrollY === 0 && !location.hash && !document.documentElement.classList.contains('no-sticky')) {
						document.documentElement.style.minHeight = (window.innerHeight + /* $lh */ 32) + 'px';
						var scrollTo = document.getElementById('initialScrollPoint');
						window.scrollTo(window.scrollX, scrollTo.getBoundingClientRect().top);
					}
				})();</script>
			</div>
		</header>

		<div class="content">
			<div class="wrapper">
				<nav class="nav" id="tableOfContents">
					<ul>
						<li data-id="getting-started">
							<a href="#getting-started">Getting started</a>
							<ul class="subsections">
								<li data-id="what-is-mayhem"><a href="#what-is-mayhem">What is Mayhem?</a></li>
								<li data-id="system-requirements"><a href="#system-requirements">System requirements</a></li>
								<li data-id="installation"><a href="#installation">Installation</a></li>
								<li data-id="reading-guide"><a href="#reading-guide">Reading this guide</a></li>
								<li data-id="first-app"><a href="#first-app">Creating your first app</a></li>
							</ul>
						</li>
						<li data-id="fundamentals">
							<a href="#fundamentals">Fundamentals</a>
							<ul class="subsections">
								<li data-id="fundamentals-overview"><a href="#fundamentals-overview">Overview</a></li>
								<li data-id="typescript"><a href="#typescript">The TypeScript language</a></li>
								<li data-id="mvvm"><a href="#mvvm">The MVVM pattern</a></li>
								<li data-id="conventions"><a href="#conventions">Conventions</a></li>
							</ul>
						</li>
						<li data-id="application">
							<a href="#application">Applications</a>
							<ul class="subsections">
								<li data-id="application-class"><a href="#application-class">Creating an application</a></li>
								<li data-id="application-components"><a href="#application-components">Application components</a></li>
							</ul>
						</li>
						<li data-id="data-binding">
							<a href="#data-binding">Data binding</a>
							<ul class="subsections">
								<li data-id="what-is-data-binding"><a href="#what-is-data-binding">What is data binding?</a></li>
								<li data-id="extending-binding"><a href="#extending-binding">Adding and extending bindings</a></li>
							</ul>
						</li>
						<li>
							<a href="#views">Views</a>
							<ul class="subsections">
							</ul>
						</li>
						<li>
							<a href="">Data models</a>
							<ul class="subsections">
							</ul>
						</li>
						<li>
							<a href="">Routing</a>
							<ul class="subsections">
							</ul>
						</li>
						<li>
							<a href="">Security</a>
							<ul class="subsections">
							</ul>
						</li>
						<li>
							<a href="">Testing</a>
							<ul class="subsections">
							</ul>
						</li>
						<li>
							<a href="">Optimising</a>
							<ul class="subsections">
							</ul>
						</li>
						<li>
							<a href="">Community</a>
							<ul class="subsections">
								<li data-id="getting-help"><a href="#getting-help">Getting help</a></li>
								<li data-id="contributing"><a href="#contributing">Contributing</a></li>
							</ul>
						</li>
					</ul>

					<p class="support"><a href="https://sitepen.com/support/index.html">Commercial support</a></p>
				</nav>

				<main class="main" id="main">
					<article>
						<div class="a" id="getting-started"></div>
						<h2 data-id="getting-started">Welcome to Mayhem</h2>

						<div class="a half" id="what-is-mayhem"></div>
						<h3 data-id="what-is-mayhem">What is Mayhem?</h3>

						<p>Mayhem is a framework for developing large, complex applications with TypeScript or JavaScript. Unlike other Web libraries and frameworks that place their emphasis on performance or file size, Mayhem is designed around these three key tenets:</p>

						<ul>
							<li><strong>Predictability</strong>: As much as possible, the framework must be designed to minimise surprise. Mayhem uses as little magic as possible in order to accomplish its goals, while still being exceptionally powerful &amp; easy to use, with a minimum of rote.</li>
							<li><strong>Extensibility</strong>: It should be possible for all parts of the framework to be easily extended or replaced with newer, better components. This allows many different classes of applications to be written, including those not envisioned when the framework was originally written, using the same standard set of tools.</li>
							<li><strong>Correctness</strong>: When writing software, it’s frustrating when your tools get you stuck. Mayhem was architected from the ground up to be modular, testable, and easy to understand in order to minimise the maintenance cost surrounding its use.</li>
						</ul>

						<p>We believe that good architecture, in combination with today’s superfast JavaScript engines, ensures a very high level of performance in nearly all use cases. As such, the clarity and maintainability of the Mayhem codebase will always be given priority over performance tweaks in all but the hottest code paths. We hope that you will see the benefit of this decision in increased productivity and less time spent troubleshooting your apps!</p>

						<h4>What is Mayhem best for?</h4>

						<p>Mayhem is a generic application development framework that can be used for developing virtually any type of client-side, server-side, or mobile application. Because of its emphasis on strict architectural patterns and conventions, it is especially well-suited for extremely large, “enterprise-level” applications that must be maintained by large teams of developers with varying skill levels.</p>

						<p>This first release of Mayhem focuses primarily on the development of form-based client-side Web applications, but we plan on rapidly expanding functionality for other types of apps. <a href="https://github.com/SitePen/mayhem/blob/master/CONTRIBUTING.md">Pull requests are accepted!</a></p>

						<div class="a half" id="system-requirements"></div>
						<h3 data-id="system-requirements">System requirements</h3>

						<p>End-users of Mayhem applications must meet the following minimum system requirements:</p>

						<table>
							<tr>
								<td>Android</td>
								<td>4.1.2+</td>
							</tr>
							<tr>
								<td>Chrome</td>
								<td>Latest</td>
							</tr>
							<tr>
								<td>Firefox</td>
								<td>Latest <abbr title="Extended Support Release">ESR</abbr> or rapid release</td>
							</tr>
							<tr>
								<td>Internet Explorer</td>
								<td>8+</td>
							</tr>
							<tr>
								<td>iOS</td>
								<td>6.1+</td>
							</tr>
							<tr>
								<td>Opera</td>
								<td>Latest</td>
							</tr>
							<tr>
								<td>Safari (Mac OS)</td>
								<td>Latest</td>
							</tr>
						</table>

						<p>Developers using Mayhem must also meet the following additional requirements:</p>

						<table>
							<tr>
								<td><a href="http://bower.io">Bower</a></td>
								<td>1.3.9+</td>
								<td>for client-side package installation</td>
							</tr>
							<tr>
								<td><a href="http://nodejs.org">Node.js</a></td>
								<td>0.10.28+</td>
								<td>for builds &amp; functional testing</td>
							</tr>
							<tr>
								<td><a href="http://npmjs.org">npm</a></td>
								<td>1.4.4+</td>
								<td>for Node.js package installation</td>
							</tr>
						</table>

						<div class="a half" id="installation"></div>
						<h3 data-id="installation">Installation</h3>

						<p>Depending upon the platform you are planning on developing for, there are three different ways in which installation can be performed:</p>

						<ul>
							<li><strong>For writing Node.js apps</strong>: Mayhem can be installed for use with Node.js by running <code>npm install mayhem</code>. This will install a copy of Mayhem that has been pre-compiled for Node.js using the CommonJS module format, plus ambient declarations that can be used when writing Mayhem applications for Node.js with TypeScript.</li>
							<li><strong>For writing browser &amp; mobile apps</strong>: Mayhem can be installed for browsers &amp; mobile devices by running <code>bower install mayhem</code>. This will install a copy of Mayhem that has been pre-compiled for asynchronously loaded environments using the <abbr title="Asynchronous Module Definition">AMD</abbr> module format, plus ambient declarations that can be used when writing Mayhem applications for browsers or mobile devices with TypeScript.</li>
							<li><strong>For working on Mayhem, or compiling your own modules</strong>: The original TypeScript source for Mayhem can be installed from our <a href="https://github.com/SitePen/mayhem" title="Mayhem on GitHub">GitHub repository</a> by running <code>git clone --recursive git@github.com:SitePen/mayhem.git</code>. The README file in the repository contains additional instructions on installation and usage of the development version of Mayhem.</li>
						</ul>

						<p>Because Mayhem is written in TypeScript, future versions of Mayhem will also be compiled to standard EcmaScript 6 modules once that format has been finalised.</p>

						<div class="a half" id="reading-guide"></div>
						<h3 data-id="reading-guide">Reading this guide</h3>

						<p>Throughout this guide, you will find certain pieces of information are called out specifically, as we have found them to be especially important or problematic for users.</p>

						<aside class="tip">
							<p>Sections that look like this contain advanced tips and tricks that can help you get the most out of Mayhem.</p>
						</aside>

						<aside class="deprecated">
							<p>Sections that look like this tell you about functionality that is deprecated and will be removed from a future version of Mayhem.</p>
						</aside>

						<aside class="whatAreYouCrazy">
							<p>Sections that look like this tell you about dangerous anti-patterns that can break, slow down, or make your application less maintainable.</p>
						</aside>

						<p>Later sections of this guide are designed to be built upon knowledge presented in earlier parts. If you jump into the middle and feel confused, step back a section or two until you find the information you need to move forward. We also accept <a href="TODO">pull requests</a> to the documentation in order to improve its flow and clarity.</p>

						<div class="a half" id="first-app"></div>
						<h3 data-id="first-app">Creating your first app</h3>

						<p>In order to simplify the creation of new applications, Mayhem comes with a command-line generator that can be used to instantly generate new applications.</p>

						<aside class="tip"><p>In the first release of Mayhem, the <span class="sc">Mayhem generator</span> generates Web applications only. Future versions will contain additional default application profiles for many other kinds of apps.</p></aside>

						<p>To get started, just run the generator for starting a Web application:</p>

						<pre class="m1"><code class="bash">$ yo mayhem webapp src</code></pre>

						<p>This will create a new skeleton Web app in the <code>src</code> directory (actually, a TodoMVC app). All that needs to be done now is to open the test application in a browser:</p>

						<pre class="m1"><tt>http://localhost/path/to/src/index.html</tt></pre>

						<p>Navigating to this index page should display a fully functioning client-side TodoMVC application, ready for you to start hacking away!</p>

						<aside class="tip"><p>The <span class="sc">Mayhem generator</span> does more than just scaffold a basic app: It automatically generate new models quickly and easily; allows you to generate routing configurations for apps that don’t have direct access to the filesystem to safely auto-discover the available views; and watches for and automatically recompiles changed TypeScript and Stylus files. Just run <tt>yo mayhem</tt> to get an overview of all the available commands.</p></aside>

						<p>TODO: Continue tutorialising the basic TodoMVC app; maybe add in user authentication or something.</p>
					</article>

					<article>
						<div class="a" id="fundamentals"></div>
						<h2 data-id="fundamentals">Fundamentals</h2>

						<div class="a half" id="fundamentals-overview"></div>
						<h3 data-id="fundamentals-overview">Overview</h3>

						<figure>
							<img src="http://placepuppy.it/1000/608">
							<figcaption>The subsystems of Mayhem</figcaption>
						</figure>

						<p>The architecture of Mayhem is divided up into eight primary subsystems:</p>

						<ul>
							<li><strong>Application</strong>: The <dfn>application subsystem</dfn> is responsible for providing a mechanism for creating new applications by configuration, dynamically loading application components at runtime using dependency injection, and providing a main application-wide object for each application that is currently running in the environment.</li>
							<li><strong>Data binding</strong>: The <dfn>data binding subsystem</dfn> is responsible for all functionality related to binding properties between two objects, and observing properties on objects for changes. This subsystem is essential for implementing the MVVM pattern, which will be discussed shortly.</li>
							<li><strong>Data modelling</strong>: The <dfn>data modelling subsystem</dfn> provides functionality related to business logic, data object creation, data validation, and communication with databases.</li>
							<li><strong>Foundation</strong>: The <dfn>foundation subsystem</dfn> provides core functionality for the entire Mayhem application framework, like observable proxy objects, utility functions, and other miscellaneous critical functionality.</li>
							<li><strong>Routing</strong>: The <dfn>routing subsystem</dfn> is responsible for discovering, loading, and linking together data models and sub-views in response to navigation within an application.</li>
							<li><strong>Security</strong>: The <dfn>security subsystem</dfn> is responsible for providing user authentication &amp; authorization, access control, and other security-oriented application functionality.</li>
							<li><strong>Templating</strong>: The <dfn>templating subsystem</dfn> is responsible for creating views and linking data models to the views using easy-to-write declarative templates.</li>
							<li><strong>Views</strong>: The <dfn>view subsystem</dfn> is responsible for handling all <abbr title="User Interface">UI</abbr> input and output.</li>
						</ul>

						<div class="a half" id="typescript"></div>
						<h3 data-id="typescript">The TypeScript language</h3>

						<p>Mayhem is written in <a href="http://typescriptlang.org">TypeScript</a> in order to take advantage of the significant maintenance benefits that come with optional strict typing and the ability to define strong interfaces. Since these features are also critical to keeping large applications maintainable over many years—especially with teams of varying disciplines and skill levels—we strongly encourage all users of Mayhem to explore using TypeScript directly when writing apps with Mayhem. However, the TypeScript compiler does generate highly-readable, well-formed JavaScript, so if you prefer to use vanilla JavaScript, go right ahead!</p>

						<aside class="tip"><p>If you’re unfamiliar with TypeScript but want to learn how to use it, check out SitePen’s <a href="http://www.sitepen.com/blog/2013/12/31/definitive-guide-to-typescript/">Definitive Guide to TypeScript</a>. Remember that TypeScript is a full superset of JavaScript, so you can always write JavaScript and migrate to TypeScript over time—or vice-versa!</p></aside>

						<p>Mayhem uses certain conventions to provide support for Proxy-like objects in pre-EcmaScript 6 environments, which are key to providing easy-to-use view-models. In order to work around limitations within the first version of TypeScript, … TODO (talking about Callers/Events/Getters/Setters interfaces here)</p>

						<figure>
							<pre><code class="typescript">import Observable = require('mayhem/Observable');

class User extends Observable {
	get:User.Getters;
	set:User.Setters;
}

module User {
	export interface Getters extends Observable.Getters {
		(key:'username'):string;
		(key:'password'):string;
	}

	export interface Setters extends Observable.Setters {
		(key:'username', value:string):void;
		(key:'password', value:string):void;
	}
}

export = User;</code></pre>
							<figcaption>Creating a basic Mayhem class in TypeScript</figcaption>
						</figure>

						<aside class="tip"><p>The <span class="sc">Mayhem generator</span> can create these more verbose data interfaces for you automatically. As the TypeScript language continues to mature, improved code generation and annotations will be used in order to eliminate the need to write longhand interface definitions. (One useful side-benefit of having to define getters and setters separately is that it becomes possible to type properties as being read-only or write-only within the compiler.)</p></aside>

						<div class="a half" id="mvvm"></div>
						<h3 data-id="mvvm">The MVVM pattern</h3>

						<figure>
							<img src="http://placepuppy.it/600/320">
							<figcaption>An overview of the MVVM pattern</figcaption>
						</figure>

						<p>Mayhem implements the model–view–view-model (<dfn><abbr title="model–view–view-model">MVVM</abbr></dfn>) architectural pattern, which separates business logic, user interface logic, and the user interface itself into three distinct layers. This pattern is similar to the Smalltalk <abbr title="model-view-controller">MVC</abbr> pattern (not to be confused with <a href="https://en.wikipedia.org/wiki/Model_2">Model 2 MVC</a>, a pattern used by server-side MVC frameworks), but it uses an improved mode of interaction between the different layers in order to avoid the “fat controller” anti-pattern common to many MVC apps.</p>

						<h4>Model</h4>

						<p>The term <dfn>model</dfn> in the context of the MVVM pattern refers to a “business” object—an object that contains code and data that performs the actual work of the business. Models operate completely independently from any user interface, so can be fully reused across many different systems. For example, if you were writing software for managing a bank, <em>bank accounts</em> and <em>transactions</em> would be two different types of <em>models</em>. Models within Mayhem are normally created by subclassing the <a href="#TODO"><code>mayhem/data/Model</code></a> class, which provides standard functionality for defining, loading, validating, and saving data.</p>

						<h4>View</h4>

						<p>The term <dfn>view</dfn> in the context of the MVVM pattern refers to an object representing part of the interactive user interface of an application. Views encapsulate both input and output: they display data to the user in the form of widgets and sub-views, and collect and dispatch user input (mouse, touch, pen, keyboard, Kinect, etc.) from the user interface back to the rest of the system, usually by calling a method on a view-model.</p>

						<h4>View-model</h4>

						<p>The term <dfn>view-model</dfn> refers to a Model object that exposes properties that are required by a specific view. For example, if you had a <em>transaction history view</em> in your application, you would create an associated view-model that exposed a <a href="TODO">Collection</a> of <code>Transaction</code> objects to display in the list, plus additional properties that could be updated by the view in order to dynamically change the contents of the <code>Transactions</code> collection.</p>

						<p>One of the key differences between an MVVM view-model and an MVC controller is that the view-model is never given a reference to its associated view. Instead, properties are [TODO: should talk about data binding before getting here?] data-bound between the view and the view-model, so that when something in the view changes, a bound property of the view-model is updated, and vice-versa. This approach allows view-models to be decoupled from and reused by multiple different views, and also allows their logic to be tested completely independently from any user interface. It also has the added benefit of preventing any UI-specific code from ending up outside of the view subsystem.</p>

						<p>In many cases, view-models are simple proxies back to real data models. For example, while a Transaction model may store the amount of a transaction in USD cents, your view may want to display the transaction amount in its equivalent in euros, with the correct currency symbol and locale-specific number formatting. Since all other information—like the transaction ID and recipient—can be taken as-is from the original data model, there is no reason to create an entirely separate view-model that re-exposes these properties just to add this one extra piece for the view. <a href="TODO"><code>mayhem/data/ProxyModel</code>s</a> allow you to wrap an existing model object with extra properties for display in a view, with all other properties delegating back to the original data model.</p>

						<div class="a half" id="conventions"></div>
						<h3 data-id="conventions">Conventions</h3>

						<h4>Object construction</h4>

						<p>All constructors in Mayhem share the same constructor signature, with a single optional <dfn>keyword arguments</dfn> object accepted as the sole argument:</p>

						<pre><code class="typescript">{ new (kwArgs?:Object):&lt;ClassType>; }</code></pre>

						<p>By passing all arguments to a constructor using a keyword arguments object instead of allowing arbitrary constructor parameters, many things become easier:</p>

						<ul>
							<li>Constructors can always be extended in a backwards-compatible manner, since new properties can simply be added to the list of accepted properties without a signature change</li>
							<li>Constructors can always be indirectly invoked using the <code>new</code> keyword, with <a href="https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible" title="“Use of .apply() with 'new' operator. Is this possible?” on Stack Overflow">no additional overhead</a></li>
							<li>All arguments are clear from the call itself and do not <a href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event-initMouseEvent" title="The DOM 2 Event#initMouseEvent API, featuring 6 number and 6 boolean parameters">require looking at the constructor’s parameter list</a></li>
							<li>No extra code is necessary for parameters that need to go through accessors/mutators, as the keyword arguments object is mass-assigned using <a href="TODO"><code>Observable#set</code></a></li>
						</ul>

						<h4>Object usage</h4>

						<p>Getting and setting the properties of most Mayhem class instances is done using <a href="TODO"><code>object.get(key)</code></a> and <a href="TODO"><code>object.set(key, value)</code></a> methods instead of using the normal property accessor (<code>.</code>) operator. This is necessary to support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_setters_and_getters">accessor/mutator functions</a> in pre-ES5 environments, and to support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy-like behaviour</a> in pre-ES6 environments.</p>

						<h4>Object destruction</h4>

						<p>When you are done working with a class instance in Mayhem, it should always be destroyed by calling <a href="TODO"><code>object.destroy</code></a>. Doing this ensures that any all internally held references to other objects that may still be retained elsewhere are broken, and that any necessary clean-up work is completed.</p>

						<h4>Event registration</h4>

						<p>Mayhem continues the best practice established in the <a href="http://dojotoolkit.org">Dojo Toolkit</a> of returning an <a href="TODO"><code>IHandle</code></a> object from methods that perform registrations (event listeners, method aspects, data bindings, registry entries, etc.) instead of providing symmetric add/remove APIs. This practice offers many significant benefits over symmetric APIs:</p>

						<ul>
							<li>You only need to keep a reference to the <code>IHandle</code> object, instead of needing to keep references to all arguments passed to the event registration function, or using hacks like namespaced events</li>
							<li>Anonymous functions can be used when registering event listeners that need to be removed later</li>
							<li>You only need to remember one way to remove any type of object registration (<code>handle.remove()</code>)</li>
							<li>Convenience APIs for mass-removal of registrations can be created without needing to know every possible type of registration</li>
							<li>Handles can be extended with additional context-specific APIs for modifying registrations (for example, to change the source or target of a data binding)</li>
						</ul>

						<h4>Module paths</h4>

						<p>Mayhem assumes that a Mayhem application will use a default set of module ID paths. Each of them can be customised if needed.</p>

						<ul>
							<li><code><strong>app/models</strong></code>: This path holds all application data models. It can be customised via <a href="TODO"><code>Application#modelPath</code></a>.</li>
							<li><code><strong>app/viewModels</strong></code>: This path holds all application view models. It can be customised via <a href="TODO"><code>Application#viewModelPath</code></a>.</li>
							<li><code><strong>app/views</strong></code>: This path holds all application views and templates. It can be customised via <a href="TODO"><code>Application#viewPath</code></a> and <a href="TODO"><code>Application#templatePath</code></a>.</li>
						</ul>

						<p>The physical location of the <code>app</code> package on the filesystem can be modified by setting [TODO: Need some Dojo configuration stuff] <code>dojoConfig.packages = [ { name: 'app', location: 'path/to/app' } ];</code> in your application’s <code>index.html</code> file.

						<h4>Routes</h4>

						<p>The default router in Mayhem will automatically generate missing keys for a route based on the route ID of a route. These keys will be generated as follows: TODO these defaults suck and will change</p>

						<ul>
							<li><code><strong>path</strong></code>: The same as the route ID.</li>
							<li><code><strong>model</strong></code>: The <code>Application#modelPath</code>, joined with the route ID, with the first letter of the last segment of the route ID capitalised. For example, given a route ID <code>transactions/account</code>, the model would become <code>app/models/transactions/Account</code>.</li>
							<li><code><strong>viewModel</strong></code>: The <code>Application#viewModelPath</code>, joined with the route ID, with the first letter of the last segment of the route ID capitalised. For example, given a route ID <code>transactions/account</code>, the view-model would become <code>app/viewModels/transactions/Account</code>.</li>
							<li><code><strong>view</strong></code>: The <code>Application#templatePath</code>, joined with the route ID, with the first letter of the last segment of the route ID capitalised. For example, given a route ID <code>transactions/account</code>, the view would become <code>mayhem/templating/html!transactions/Account.html</code>.</li>
						</ul>

						<h4>Code conventions</h4>

						<p>Mayhem follows most normal TypeScript code conventions, with the exception that spaces are not normally placed before type definitions in order to provide better disambiguation at a glance between a type value (no space) and an object literal value (space). A <a href="https://github.com/palantir/tslint">tslint</a> profile for Mayhem, along with an up-to-date description of all code conventions, is available in the TODO <a href="https://github.com/SitePen/mayhem/blob/master/README.md">README</a> within the Mayhem repository.</p>
					</article>

					<article>
						<div class="a" id="application"></div>
						<h2 data-id="application">The Application subsystem</h2>

						<div class="a half" id="application-class"></div>
						<h3 data-id="application-class">Creating an application</h3>

						<p>Mayhem provides a base <a href="TODO"><code>mayhem/Application</code> class</a> for creating new applications:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');</code></pre>

						<p>New applications are created simply by instantiating a new Application object:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application();</code></pre>

						<p>A Mayhem application can be very easily customised just by passing a configuration object to the constructor:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers'
});

log(app.get('name'));</code></pre>
							<pre class="align-bottom"><code class="javascript">'Bob’s Burgers'</code></pre>
						</div>

						<aside class="tip"><p>The <code>name</code> property of an application will be used as the title of the application in user interfaces that support titles.</p></aside>

						<p>It is also possible to create custom applications by subclassing an existing Application class. For example, the <a href="TODO"><code>mayhem/WebApplication</code> class</a> is a subclass of <code>mayhem/Application</code> with a different default configuration suitable for writing Web applications.</p>

						<aside class="tip"><p><code>mayhem/WebApplication</code> is recommended as the default class for all applications created with the initial release of Mayhem, which focuses primarily on client-side Web apps. Future versions of Mayhem will include more Application subclasses to choose from for native mobile, server-side, and command-line apps.</p></aside></p>

						<p>Once the application object is ready for use, call <code>app.startup()</code> to start it:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers'
});

log(app.startup().then(function () {
	// started successfully
}, function (error:Error) {
	// an error occurred during startup
}));</code></pre>
							<pre class="align-bottom"><code class="javascript">&lt;Promise></code></pre>
						</div>

						<div class="a half" id="application-components"></div>
						<h3 data-id="application-components">Application components</h3>

						<p>The Application class on its own does relatively little; its power comes in the ability to dynamically load and instantiate different <dfn>application components</dfn> that implement the individual functions necessary to create a complete application. For example, the <a href="TODO"><code>mayhem/binding/Binder</code> class</a> is an application component that is used to perform all data binding within an application, and the <a href="TODO"><code>mayhem/ui/Master</code> class</a> is an application component that is used to provide a user interface.</p>

						<p>The default Mayhem application components can be overridden with custom implementations. However, keep in mind that some parts of the framework that require features from application components expect them to exist at specific keys on the Application instance:</p>

						<ul>
							<li><code><strong>binder</strong></code>: An implementation of the <a href="TODO"><code>mayhem/binding/interfaces.IBinder</code></a> interface. Provides data binding.</li>
							<li><code><strong>router</strong></code>: An implementation of the <a href="TODO"><code>mayhem/routing/interfaces.IRouter</code></a> interface. Provides navigation &amp; application state management.</li>
							<li><code><strong>scheduler</strong></code>: An implementation of the <a href="TODO"><code>mayhem/interfaces.IScheduler</code></a> interface. Provides event scheduling.</li>
							<li><code><strong>ui</strong></code>: An implementation of the <a href="TODO"><code>mayhem/ui/Master</code></a> interface. Provides user interface support.</li>
						</ul>

						<p>Application components can be dynamically added to an application at runtime using the <a href="TODO"><code>components</code></a> property of the configuration object. The configuration object gets <a href="TODO">deep copied</a> onto the default configuration, so default application components will continue to exist even if they are not set in the configuration object:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: {
		constructor: 'mayhem/binding/Binder',
		bindings: [ /* … */ ]
	},
	/* … */
	burgerStore: {
		constructor: 'app/stores/RestStore',
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<p>The default application components can be disabled by explicitly setting them to <code>null</code>:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: null,
		/* … */
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: null,
	/* … */
	burgerStore: {
		constructor: 'app/stores/RestStore',
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>Removing default application components from any of the built-in Application classes will probably cause Mayhem to break! Only use this technique to disable optional components in your own Application subclasses.</p></aside>

						<p>Deep copying also means that the properties of default application components can be tweaked without having to rewrite the entire component declaration:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: {
			useScheduler: false
		},
		/* … */
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: {
		constructor: 'mayhem/binding/Binder',
		useScheduler: false
	},
	/* … */
}</code></pre>
						</div>

						<p>Using a string value for a <code>constructor</code> property causes the Application instance to dynamically load a module matching the given string once it is started. The value of the module will be used as the constructor function to create a component.</p>

						<p>Application component constructors can also be explicitly imported and provided directly, which helps to automate <a href="TODO">build-time dependency resolution</a>:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');
import RestStore = require('./stores/RestStore');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: null,
		burgerStore: {
			constructor: RestStore,
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: null,
	scheduler: { /* ... */ },
	burgerStore: {
		constructor: RestStore(),
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<p>Once the application has been started, it will perform these actions:</p>

						<ol>
							<li>Freeze the <code>components</code> property so it can no longer be modified</li>
							<li>Load modules for any unloaded application components whose <code>constructor</code> properties were strings</li>
							<li>Instantiate all the application components, assigning them each to the corresponding key directly on the Application instance</li>
							<li>Call the <code>startup</code> method on all application components that need to perform additional startup actions</li>
							<li>Wait for all application components to finish starting</li>
							<li>Resolve the returned <code>startup</code> promise</li>
						</ol>

						<p>Application components are instantiated using the value of the <a href="TODO"><code>constructor</code></a> property from the configuration object as the constructor function. The rest of the properties on the configuration object, plus an extra <code>app</code> property pointing to the Application instance, are passed as keyword arguments to the constructor:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');
import Observable = require('mayhem/Observable');
import Promise = require('mayhem/Promise');

class BurgerComponent extends Observable {
	constructor(kwArgs?:Object) {
		super(kwArgs);
		log(kwArgs);
	}

	startup():Promise&lt;void> {
		// a component can do its own startup work here,
		// and optionally return a Promise for asynchronous
		// work
		return new Promise(function (resolve:Promise.IResolver&lt;void>) {
			setTimeout(resolve, 1000);
		});
	}
}

var app = new Application({
	components: {
		burgers: {
			constructor: BurgerComponent,
			buns: [ 'regular', 'sesame' ],
			meats: [ 'beef', 'turkey', 'veggie' ],
			toppings: [ 'cheese', 'onion', 'tomato' ]
		}
	}
});

app.startup().then(function () {
	log(app.get('burgers'));
});
</code></pre>
							<pre><code class="javascript">





{
	app: &lt;Application> { /* … */ },
	buns: [ /* … */ ],
	meats: [ /* … */ ],
	toppings: [ /* … */ ]
}











&lt;BurgerComponent> {
	get('app'): &lt;Application> { /* … */ },
	get('buns'): [ /* … */ ],
	get('meats'): [ /* … */ ],
	get('toppings'): [ /* … */ ]
}</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>Application components should always use their own <code>app</code> property to find their owner Application instance. Using an explicit module reference with <code>import</code> or <code>require()</code> is an anti-pattern that makes testing and reuse of application components more difficult. Application components that instantiate other objects should pass the <code>app</code> property to these objects if they also need a reference back to the application.</p></aside>

						<p>Exporting the application object makes it available for direct reference by other modules later:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

// TODO: `run`
app.startup();

export = app;</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>It is strongly recommended to pass the application object directly to constructors instead of having constructor modules explicitly reference the application module. For convenience, the <a href="TODO">data modelling subsystem</a> can be configured with a default application object based on module identifier. This is the only place where this functionality should normally be used.</p></aside>

<!--					<article>
						<p>Views can be created pro [TODO: Currently Widget in the code] the <a href="TODO"><code>mayhem/ui/View</code></a> class and constructed programmatically, or they can be generated declaratively by using a templating engine.</p> -->
					</article>

					<article>
						<div class="a" id="data-binding"></div>
						<h2 data-id="data-binding">Data binding subsystem</h2>

						<div class="a half" id="what-is-data-binding"></div>
						<h3 data-id="what-is-data-binding">What is data binding?</h3>

						<p>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br>TODO<br></p>
					</article>
				</main>
			</div>
		</div>
		<script src="css/highlight.pack.js"></script>
		<script src="css/main.js"></script>
	</body>
</html>
