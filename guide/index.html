<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
		<title>Mayhem ◇ User guide</title>
		<link rel="stylesheet" href="css/main.css">
		<script>
(function () {
	var test = document.createElement('b');
	for (var prefix in { '': 1, '-webkit-': 1 }) {
		var position = prefix + 'sticky';
		test.style.position = position;
		if (test.style.position === position) {
			return;
		}
	}
	document.documentElement.classList.add('no-sticky');
})();
		</script>
	</head>
	<body>
		<span role="button" id="showMenu" class="icon-menu"
			aria-controls="tableOfContents"
			aria-expanded="false"
			tabindex="0"
			title="Table of contents">Menu</span>
		<header class="header">
			<div class="wrapper">
				<div class="preTitle">
					<a class="logo" href=""><img alt="Mayhem logo"></a>
					<nav id="mainMenu">
						<ul>
							<li><a href="">About</a></li>
							<li><a href=""><span class="hide-680">User </span>guide</a></li>
							<li><a href="">API<span class="hide-680"> reference</span></a></li>
							<li><a href="">Community</a></li>
						</ul>
					</nav>
				</div>
				<div id="initialScrollPoint">
					<label class="search" role="search">
						<input type="text">
						<span class="icon-search"></span>
					</label>
					<h1 class="title"><span class="bold">Mayhem</span> user guide</h1>
				</div>
				<script>
(function () {
	if (window.scrollY === 0 && !location.hash && !document.documentElement.classList.contains('no-sticky')) {
		document.documentElement.style.minHeight = (window.innerHeight + /* $lh */ 32) + 'px';
		var scrollTo = document.getElementById('initialScrollPoint');
		window.scrollTo(window.scrollX, scrollTo.getBoundingClientRect().top);
	}
})();
				</script>
			</div>
		</header>

		<div class="content">
			<div class="wrapper">
				<nav class="nav" id="tableOfContents">
					<ul>
						<li data-id="getting-started">
							<a href="#getting-started">Getting started</a>
							<ul class="subsections">
								<li data-id="what-is-mayhem"><a href="#what-is-mayhem">What is Mayhem?</a></li>
								<li data-id="system-requirements"><a href="#system-requirements">System requirements</a></li>
								<li data-id="installation"><a href="#installation">Installation</a></li>
								<li data-id="reading-guide"><a href="#reading-guide">Reading this guide</a></li>
								<li data-id="first-app"><a href="#first-app">Creating your first app</a></li>
							</ul>
						</li>
						<li data-id="fundamentals">
							<a href="#fundamentals">Fundamentals</a>
							<ul class="subsections">
								<li data-id="fundamentals-overview"><a href="#fundamentals-overview">Overview</a></li>
								<li data-id="typescript"><a href="#typescript">The TypeScript language</a></li>
								<li data-id="mvvm"><a href="#mvvm">The MVVM pattern</a></li>
								<li data-id="conventions"><a href="#conventions">Conventions</a></li>
								<li data-id="base-object"><a href="#base-object">The Base object</a></li>
							</ul>
						</li>
						<li data-id="application">
							<a href="#application">Applications</a>
							<ul class="subsections">
								<li data-id="application-class"><a href="#application-class">Creating an application</a></li>
								<li data-id="application-components"><a href="#application-components">Application components</a></li>
							</ul>
						</li>
						<li data-id="data-binding">
							<a href="#data-binding">Data binding</a>
							<ul class="subsections">
								<li data-id="what-is-data-binding"><a href="#what-is-data-binding">What is data binding?</a></li>
								<li data-id="how-to-data-bind"><a href="#how-to-data-bind">How to bind data in Mayhem</a></li>
								<li data-id="binding-arrays"><a href="#binding-arrays">Binding to arrays and collections</a></li>
								<li data-id="extending-binding"><a href="#extending-binding">Adding and extending bindings</a></li>
							</ul>
						</li>
						<li>
							<a href="#routing">Routing</a>
							<ul class="subsections">
								<li data-id="what-is-routing"><a href="#what-is-routing">What is routing?</a></li>
								<li data-id="defining-routes"><a href="#defining-routes">Defining routes</a></li>
								<li data-id="custom-paths"><a href="#custom-paths">Creating custom paths</a></li>
								<li data-id="pausing-routes"><a href="#pausing-routes">Pausing &amp; cancelling route changes</a></li>
							</ul>
						</li>
						<li>
							<a href="#views">Views</a>
							<ul class="subsections">
								<li data-id="mayhem-views"><a href="#mayhem-views">How views work</a></li>
								<li data-id="view-templating"><a href="#view-templating">View templating</a></li>
								<li data-id="cross-platform-views"><a href="#cross-platform-views">Using cross-platform views</a></li>
								<li data-id="event-system"><a href="#event-system">The event system</a></li>
								<li data-id="custom-platform-widgets"><a href="#custom-platform-widgets">Custom platform widgets</a></li>
							</ul>
						</li>
						<li>
							<a href="#data-models">Data models</a>
							<ul class="subsections">
								<li data-id="what-is-data-model"><a href="#what-is-data-model">What is a data model?</a></li>
								<li data-id="scenarios"><a href="#scenarios">Scenarios</a></li>
								<li data-id="validation"><a href="#validation">Validation</a></li>
							</ul>
						</li>
						<li>
							<a href="#collections">Collections</a>
							<ul class="subsections">
								<li data-id="what-is-collection"><a href="#what-is-collection">What is a collection?</a></li>
								<li data-id="creating-collections"><a href="#creating-collections">Creating collections</a></li>
								<li data-id="wrapping-collections"><a href="#wrapping-collections">Creating view model collections</a></li>
							</ul>
						</li>
						<li>
							<a href="#security">Security</a>
							<ul class="subsections">
								<li data-id="user-object"><a href="#user-object">The User object</a></li>
								<li data-id="rbac"><a href="#rbac">Role-based access control</a></li>
							</ul>
						</li>
						<li>
							<a href="#testing">Testing</a>
							<ul class="subsections">
								<li data-id="testing"><a href="#testing">Testing Mayhem apps</a></li>
								<li data-id="testing-best-practices"><a href="#testing-best-practices">Best practices</a></li>
							</ul>
						</li>
						<li>
							<a href="#optimising">Optimising</a>
							<ul class="subsections">
								<li data-id="optimising"><a href="#optimising">Creating builds</a></li>
								<li data-id="optimising-best-practices"><a href="#optimising-best-practices">Best practices</a></li>
							</ul>
						</li>
						<li>
							<a href="#community">Community</a>
							<ul class="subsections">
								<li data-id="getting-help"><a href="#getting-help">Getting help</a></li>
								<li data-id="contributing"><a href="#contributing">Contributing</a></li>
							</ul>
						</li>
					</ul>

					<p class="support"><a href="https://sitepen.com/support/index.html">Commercial support</a></p>
				</nav>

				<main class="main" id="main">
					<article>
						<div class="a" id="getting-started"></div>
						<h2 data-id="getting-started">Welcome to Mayhem</h2>

						<div class="a half" id="what-is-mayhem"></div>
						<h3 data-id="what-is-mayhem">What is Mayhem?</h3>

						<p>Mayhem is a framework for developing large, complex applications with TypeScript or JavaScript. Unlike other Web libraries and frameworks that place their emphasis on performance or file size, Mayhem is designed around these three key tenets:</p>

						<ul>
							<li><strong>Predictability</strong>: As much as possible, the framework must be designed to minimise surprise. Mayhem uses as little magic as possible in order to accomplish its goals, while still being exceptionally powerful &amp; easy to use, with a minimum of rote.</li>
							<li><strong>Extensibility</strong>: It must be possible for all parts of the framework to be easily extended or replaced with newer, better components. This allows many different classes of applications to be written, including those not envisioned when the framework was originally written, using the same standard set of tools.</li>
							<li><strong>Correctness</strong>: When writing software, it’s frustrating when your tools get you stuck. Mayhem was architected from the ground up to be modular, testable, and easy to understand in order to minimise the maintenance cost surrounding its use.</li>
						</ul>

						<p>We believe that good architecture, in combination with today’s superfast JavaScript engines, ensures a very high level of performance in nearly all use cases. As such, the clarity and maintainability of the Mayhem codebase will always be given priority over performance tweaks in all but the hottest code paths. We hope that you will see the benefit of this decision in increased productivity and less time spent troubleshooting your apps!</p>

						<h4>What is Mayhem best for?</h4>

						<p>Mayhem is a generic application development framework that can be used for developing virtually any type of client-side, server-side, or mobile application. Because of its emphasis on strict architectural patterns and conventions, it is especially well-suited for extremely large, “enterprise-level” applications that must be maintained by large teams of developers with varying skill levels.</p>

						<p>This first release of Mayhem focuses primarily on the development of form-based client-side Web applications, but we plan on rapidly expanding functionality for other types of apps. <a href="https://github.com/SitePen/mayhem/blob/master/CONTRIBUTING.md">Pull requests are accepted!</a></p>

						<div class="a half" id="system-requirements"></div>
						<h3 data-id="system-requirements">System requirements</h3>

						<p>End-users of Mayhem applications must meet the following minimum system requirements:</p>

						<table>
							<tr>
								<td>Android</td>
								<td>4.1.2+</td>
							</tr>
							<tr>
								<td>Chrome</td>
								<td>Latest</td>
							</tr>
							<tr>
								<td>Firefox</td>
								<td>Latest <abbr title="Extended Support Release">ESR</abbr> or rapid release</td>
							</tr>
							<tr>
								<td>Internet Explorer</td>
								<td>8+</td>
							</tr>
							<tr>
								<td>iOS</td>
								<td>6.1+</td>
							</tr>
							<tr>
								<td>Opera</td>
								<td>Latest</td>
							</tr>
							<tr>
								<td>Safari (Mac OS)</td>
								<td>Latest</td>
							</tr>
						</table>

						<p>Developers using Mayhem must also meet the following additional requirements:</p>

						<table>
							<tr>
								<td><a href="http://bower.io">Bower</a></td>
								<td>1.3.9+</td>
								<td>for client-side package installation</td>
							</tr>
							<tr>
								<td><a href="http://nodejs.org">Node.js</a></td>
								<td>0.10.28+</td>
								<td>for builds &amp; functional testing</td>
							</tr>
							<tr>
								<td><a href="http://npmjs.org">npm</a></td>
								<td>1.4.4+</td>
								<td>for Node.js package installation</td>
							</tr>
						</table>

						<div class="a half" id="installation"></div>
						<h3 data-id="installation">Installation</h3>

						<p>Depending upon the platform you are planning on developing for, there are three different ways in which installation can be performed:</p>

						<ul>
							<li><strong>For writing Node.js apps</strong>: Mayhem can be installed for use with Node.js by running <code>npm install mayhem</code>. This will install a copy of Mayhem that has been pre-compiled for Node.js using the CommonJS module format, plus ambient declarations that can be used when writing Mayhem applications for Node.js with TypeScript.</li>
							<li><strong>For writing browser &amp; mobile apps</strong>: Mayhem can be installed for browsers &amp; mobile devices by running <code>bower install mayhem</code>. This will install a copy of Mayhem that has been pre-compiled for asynchronously loaded environments using the <abbr title="Asynchronous Module Definition">AMD</abbr> module format, plus ambient declarations that can be used when writing Mayhem applications for browsers or mobile devices with TypeScript. Bower can be installed from npm by running <code>npm install -g bower</code>.</li>
							<li><strong>For working on Mayhem, or compiling your own modules</strong>: The original TypeScript source for Mayhem can be installed from our <a href="https://github.com/SitePen/mayhem" title="Mayhem on GitHub">GitHub repository</a> by running <code>git clone --recursive git@github.com:SitePen/mayhem.git</code>. The README file in the repository contains additional instructions on installation and usage of the development version of Mayhem.</li>
						</ul>

						<p>Because Mayhem is written in TypeScript, future versions of Mayhem will also be compiled to standard EcmaScript 6 modules once that format has been finalised.</p>

						<div class="a half" id="reading-guide"></div>
						<h3 data-id="reading-guide">Reading this guide</h3>

						<p>Throughout this guide, you will find certain pieces of information are called out specifically, as we have found them to be especially important or problematic for users.</p>

						<aside class="tip">
							<p>Sections that look like this contain advanced tips and tricks that can help you get the most out of Mayhem.</p>
						</aside>

						<aside class="deprecated">
							<p>Sections that look like this tell you about functionality that is deprecated and will be removed from a future version of Mayhem.</p>
						</aside>

						<aside class="whatAreYouCrazy">
							<p>Sections that look like this tell you about dangerous anti-patterns that can break, slow down, or make your application less maintainable.</p>
						</aside>

						<p>Later sections of this guide are designed to be built upon knowledge presented in earlier parts. If you jump into the middle and feel confused, step back a section or two until you find the information you need to move forward. We also accept <a href="TODO">pull requests</a> to the documentation in order to improve its flow and clarity.</p>

						<div class="a half" id="first-app"></div>
						<h3 data-id="first-app">Creating your first app</h3>

						<p>In order to simplify the creation of new applications, Mayhem comes with a command-line generator that can be used to instantly generate new applications.</p>

						<aside class="tip"><p>In the first release of Mayhem, the <span class="sc">Mayhem generator</span> generates Web applications only. Future versions will contain additional default application profiles for many other kinds of apps.</p></aside>

						<p>To get started, just run the generator for starting a Web application:</p>

						<pre class="m1"><code class="bash">$ yo mayhem webapp src</code></pre>

						<p>This will create a new skeleton Web app in the <code>src</code> directory (actually, a TodoMVC app). All that needs to be done now is to open the test application in a browser:</p>

						<pre class="m1"><tt>http://localhost/path/to/src/index.html</tt></pre>

						<p>Navigating to this index page should display a fully functioning client-side TodoMVC application, ready for you to start hacking away!</p>

						<aside class="tip"><p>The <span class="sc">Mayhem generator</span> does more than just scaffold a basic app: It automatically generate new models quickly and easily; allows you to generate routing configurations for apps that don’t have direct access to the filesystem to safely auto-discover the available views; and watches for and automatically recompiles changed TypeScript and Stylus files. Just run <tt>yo mayhem</tt> to get an overview of all the available commands.</p></aside>

						<p>TODO: Continue tutorialising the basic TodoMVC app; maybe add in user authentication or something.</p>
					</article>

					<article>
						<div class="a" id="fundamentals"></div>
						<h2 data-id="fundamentals">Fundamentals</h2>

						<div class="a half" id="fundamentals-overview"></div>
						<h3 data-id="fundamentals-overview">Overview</h3>

						<figure>
							<img src="http://placekitten.com/1000/608">
							<figcaption>The subsystems of Mayhem</figcaption>
						</figure>

						<p>The architecture of Mayhem is divided up into eight primary subsystems:</p>

						<ul>
							<li><strong>Application</strong>: The <dfn>application subsystem</dfn> is responsible for providing a mechanism for creating new applications by configuration, dynamically loading application components at runtime using dependency injection, and providing a main application-wide object for each application that is currently running in the environment.</li>
							<li><strong>Data binding</strong>: The <dfn>data binding subsystem</dfn> is responsible for all functionality related to binding properties between two objects, and observing properties on objects for changes. This subsystem is essential for implementing the MVVM pattern, which will be discussed shortly.</li>
							<li><strong>Data modelling</strong>: The <dfn>data modelling subsystem</dfn> provides functionality related to business logic, data object creation, data validation, and communication with databases.</li>
							<li><strong>Foundation</strong>: The <dfn>foundation subsystem</dfn> provides core functionality for the entire Mayhem application framework, like observable proxy objects, utility functions, and other miscellaneous critical functionality.</li>
							<li><strong>Routing</strong>: The <dfn>routing subsystem</dfn> is responsible for discovering, loading, and linking together data models and sub-views in response to navigation within an application.</li>
							<li><strong>Security</strong>: The <dfn>security subsystem</dfn> is responsible for providing user authentication &amp; authorization, access control, and other security-oriented application functionality.</li>
							<li><strong>Templating</strong>: The <dfn>templating subsystem</dfn> is responsible for creating views and linking data models to the views using easy-to-write declarative templates.</li>
							<li><strong>Views</strong>: The <dfn>view subsystem</dfn> is responsible for handling all <abbr title="User Interface">UI</abbr> input and output.</li>
						</ul>

						<div class="a half" id="typescript"></div>
						<h3 data-id="typescript">The TypeScript language</h3>

						<p>Mayhem is written in <a href="http://typescriptlang.org">TypeScript</a> in order to take advantage of the significant maintenance benefits that come with optional strict typing and the ability to define strong interfaces. Since these features are also critical to keeping large applications maintainable over many years—especially with teams of varying disciplines and skill levels—we strongly encourage all users of Mayhem to explore using TypeScript directly when writing apps with Mayhem. However, the TypeScript compiler does generate highly-readable, well-formed JavaScript, so if you prefer to use vanilla JavaScript, go right ahead!</p>

						<aside class="tip"><p>If you’re unfamiliar with TypeScript but want to learn how to use it, check out SitePen’s <a href="http://www.sitepen.com/blog/2013/12/31/definitive-guide-to-typescript/">Definitive Guide to TypeScript</a>. Remember that TypeScript is a full superset of JavaScript, so you can always write JavaScript and migrate to TypeScript over time—or vice-versa!</p></aside>

						<p>Mayhem uses certain conventions to provide support for Proxy-like objects in pre-EcmaScript 6 environments, which are key to providing easy-to-use view-models. In order to work around limitations within the first version of TypeScript, … TODO (talking about Callers/Events/Getters/Setters interfaces here)</p>

						<figure>
							<pre><code class="typescript">import Observable = require('mayhem/Observable');

class User extends Observable {
	get:User.Getters;
	set:User.Setters;
}

module User {
	export interface Getters extends Observable.Getters {
		(key:'username'):string;
		(key:'password'):string;
	}

	export interface Setters extends Observable.Setters {
		(key:'username', value:string):void;
		(key:'password', value:string):void;
	}
}

export = User;</code></pre>
							<figcaption>Creating a basic Mayhem class in TypeScript</figcaption>
						</figure>

						<aside class="tip"><p>The <span class="sc">Mayhem generator</span> can create these more verbose data interfaces for you automatically. As the TypeScript language continues to mature, improved code generation and annotations will be used in order to eliminate the need to write longhand interface definitions. (One useful side-benefit of having to define getters and setters separately is that it becomes possible to type properties as being read-only or write-only within the compiler.)</p></aside>

						<div class="a half" id="mvvm"></div>
						<h3 data-id="mvvm">The MVVM pattern</h3>

						<figure>
							<img src="http://placekitten.com/600/320">
							<figcaption>An overview of the MVVM pattern</figcaption>
						</figure>

						<p>Mayhem implements the model–view–view-model (<dfn>MVVM</dfn>) architectural pattern, which separates business logic, user interface logic, and the user interface itself into three distinct layers. This pattern is similar to the Smalltalk <abbr title="model-view-controller">MVC</abbr> pattern (not to be confused with <a href="https://en.wikipedia.org/wiki/Model_2">Model 2 MVC</a>, a pattern used by server-side MVC frameworks), but it uses an improved mode of interaction between the different layers in order to avoid the “fat controller” anti-pattern common to many MVC apps.</p>

						<h4>Model</h4>

						<p>The term <dfn>model</dfn> in the context of the MVVM pattern refers to a “business” object—an object that contains code and data that performs the actual work of the business. Models operate completely independently from any user interface, so can be fully reused across many different systems. For example, if you were writing software for managing a bank, <em>bank accounts</em> and <em>transactions</em> would be two different types of <em>models</em>. Models within Mayhem are normally created by subclassing the <a href="#TODO"><code>mayhem/data/Model</code></a> class, which provides standard functionality for defining, loading, validating, and saving data.</p>

						<h4>View</h4>

						<p>The term <dfn>view</dfn> in the context of the MVVM pattern refers to an object representing part of the interactive user interface of an application. Views encapsulate both input and output: they display data to the user in the form of widgets and sub-views, and collect and dispatch user input (mouse, touch, pen, keyboard, Kinect, etc.) from the user interface back to the rest of the system, usually by calling a method on a view-model.</p>

						<h4>View-model</h4>

						<p>The term <dfn>view-model</dfn> refers to a Model object that exposes properties that are required by a specific view. For example, if you had a <em>transaction history view</em> in your application, you would create an associated view-model that exposed a <a href="TODO">Collection</a> of <code>Transaction</code> objects to display in the list, plus additional properties that could be updated by the view in order to dynamically change the contents of the <code>Transactions</code> collection.</p>

						<p>One of the key differences between an MVVM view-model and an MVC controller is that the view-model is never given a reference to its associated view. Instead, properties are [TODO: should talk about data binding before getting here?] data-bound between the view and the view-model, so that when something in the view changes, a bound property of the view-model is updated, and vice-versa. This approach allows view-models to be decoupled from and reused by multiple different views, and also allows their logic to be tested completely independently from any user interface. It also has the added benefit of preventing any UI-specific code from ending up outside of the view subsystem.</p>

						<p>In many cases, view-models are simple proxies back to real data models. For example, while a Transaction model may store the amount of a transaction in USD cents, your view may want to display the transaction amount in its equivalent in euros, with the correct currency symbol and locale-specific number formatting. Since all other information—like the transaction ID and recipient—can be taken as-is from the original data model, there is no reason to create an entirely separate view-model that re-exposes these properties just to add this one extra piece for the view. <a href="TODO"><code>mayhem/data/ProxyModel</code>s</a> allow you to wrap an existing model object with extra properties for display in a view, with all other properties delegating back to the original data model.</p>

						<div class="a half" id="conventions"></div>
						<h3 data-id="conventions">Conventions</h3>

						<h4>Object construction</h4>

						<p>All constructors in Mayhem share the same constructor signature, with a single optional <dfn>keyword arguments</dfn> object accepted as the sole argument:</p>

						<pre><code class="typescript">{ new (kwArgs?:Object):&lt;ClassType>; }</code></pre>

						<p>By passing all arguments to a constructor using a keyword arguments object instead of allowing arbitrary constructor parameters, many things become easier:</p>

						<ul>
							<li>Constructors can always be extended in a backwards-compatible manner, since new properties can simply be added to the list of accepted properties without a signature change</li>
							<li>Constructors can always be indirectly invoked using the <code>new</code> keyword, with <a href="https://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible" title="“Use of .apply() with 'new' operator. Is this possible?” on Stack Overflow">no additional overhead</a></li>
							<li>All arguments are clear from the call itself and do not <a href="https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-Event-initMouseEvent" title="The DOM 2 Event#initMouseEvent API, featuring 6 number and 6 boolean parameters">require looking at the constructor’s parameter list</a></li>
							<li>No extra code is necessary for parameters that need to go through accessors/mutators, as the keyword arguments object is mass-assigned using <a href="TODO"><code>Observable#set</code></a></li>
						</ul>

						<h4>Object usage</h4>

						<p>Getting and setting the properties of most Mayhem class instances is done using <a href="TODO"><code>object.get(key)</code></a> and <a href="TODO"><code>object.set(key, value)</code></a> methods instead of using the normal property accessor (<code>.</code>) operator. This is necessary to support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Custom_setters_and_getters">accessor/mutator functions</a> in pre-ES5 environments, and to support <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy-like behaviour</a> in pre-ES6 environments.</p>

						<h4>Object destruction</h4>

						<p>When you are done working with a class instance in Mayhem, it should always be destroyed by calling <a href="TODO"><code>object.destroy</code></a>. Doing this ensures that any internally held references to other objects that may still be retained elsewhere are broken, and that any necessary clean-up work is completed.</p>

						<h4>Event registration</h4>

						<p>Mayhem continues the best practice established in the <a href="http://dojotoolkit.org">Dojo Toolkit</a> of returning an <a href="TODO"><code>IHandle</code></a> object from methods that perform registrations (event listeners, method aspects, data bindings, registry entries, etc.) instead of providing symmetric add/remove APIs. This practice offers many significant benefits over symmetric APIs:</p>

						<ul>
							<li>You only need to keep a reference to the <code>IHandle</code> object, instead of needing to keep references to all arguments passed to the event registration function, or using hacks like namespaced events</li>
							<li>Anonymous functions can be used when registering event listeners that need to be removed later</li>
							<li>You only need to remember one way to remove any type of object registration (<code>handle.remove()</code>)</li>
							<li>Convenience APIs for mass-removal of registrations can be created without needing to know every possible type of registration</li>
							<li>Handles can be extended with additional context-specific APIs for modifying registrations (for example, to change the source or target of a data binding)</li>
						</ul>

						<h4>Module paths</h4>

						<p>Mayhem assumes that a Mayhem application will use a default set of module ID paths. Each of them can be customised if needed.</p>

						<ul>
							<li><code><strong>app/models</strong></code>: This path holds all application data models. It can be customised via <a href="TODO"><code>Application#modelPath</code></a>.</li>
							<li><code><strong>app/viewModels</strong></code>: This path holds all application view models. It can be customised via <a href="TODO"><code>Application#viewModelPath</code></a>.</li>
							<li><code><strong>app/views</strong></code>: This path holds all application views and templates. It can be customised via <a href="TODO"><code>Application#viewPath</code></a> and <a href="TODO"><code>Application#templatePath</code></a>.</li>
						</ul>

						<p>The physical location of the <code>app</code> package on the filesystem can be modified by setting [TODO: Need some Dojo configuration stuff] <code>dojoConfig.packages = [ { name: 'app', location: 'path/to/app' } ];</code> in your application’s <code>index.html</code> file.

						<h4>Routes</h4>

						<p>The default router in Mayhem will automatically generate missing keys for a route based on the route ID of a route. These keys will be generated as follows: TODO these defaults suck and will change</p>

						<ul>
							<li><code><strong>path</strong></code>: The same as the route ID.</li>
							<li><code><strong>model</strong></code>: The <code>Application#modelPath</code>, joined with the route ID, with the first letter of the last segment of the route ID capitalised. For example, given a route ID <code>transactions/account</code>, the model would become <code>app/models/transactions/Account</code>.</li>
							<li><code><strong>viewModel</strong></code>: The <code>Application#viewModelPath</code>, joined with the route ID, with the first letter of the last segment of the route ID capitalised. For example, given a route ID <code>transactions/account</code>, the view-model would become <code>app/viewModels/transactions/Account</code>.</li>
							<li><code><strong>view</strong></code>: The <code>Application#templatePath</code>, joined with the route ID, with the first letter of the last segment of the route ID capitalised. For example, given a route ID <code>transactions/account</code>, the view would become <code>mayhem/templating/html!transactions/Account.html</code>.</li>
						</ul>

						<h4>Code conventions</h4>

						<p>Mayhem follows most normal TypeScript code conventions, with the exception that spaces are not normally placed before type definitions in order to provide better disambiguation at a glance between a type value (no space) and an object literal value (space). A <a href="https://github.com/palantir/tslint">tslint</a> profile for Mayhem, along with an up-to-date description of all code conventions, is available in the TODO <a href="https://github.com/SitePen/mayhem/blob/master/README.md">README</a> within the Mayhem repository.</p>

						<div class="a half" id="base-object"></div>
						<h3 data-id="base-object">The Base object</h3>

						<p>Within Mayhem, most objects are extended from the Observable (TODO: rename) object. The Observable object provides a consistent API for getting and setting properties that allows computed properties to be created in EcmaScript 3 environments and that allows proxy-like interactions to be created in EcmaScript 5 environments.</p>

						<h4>Setters vs observers</h4>

						<p>When creating components that extend from Observable, it’s important to distinguish between the functionality of a setter function and the functionality of an observer function:</p>

						<ul>
							<li>A <em>setter function</em> should be used when the way in which a property is set needs to be changed. For example, if you had a computed <code>formattedPrice</code> property that computed a human-readable price, you could also have a setter function to convert a formatted price value back into a number and then set it on <code>price</code>.</li>
							<li>An <em>observer function</em> should be used when an object needs to respond to the fact that a particular property has changed. For example, if you had a computed <code>totalPrice</code> property that was based on the subtotals of items in a shopping cart, the property would never be set directly but it would update frequently as items were added and removed from the cart.</li>
						</ul>
					</article>

					<article>
						<div class="a" id="application"></div>
						<h2 data-id="application">The Application subsystem</h2>

						<div class="a half" id="application-class"></div>
						<h3 data-id="application-class">Creating an application</h3>

						<p>Mayhem provides a base <a href="TODO"><code>mayhem/Application</code> class</a> for creating new applications:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');</code></pre>

						<p>New applications are created simply by instantiating a new Application object:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application();</code></pre>

						<p>A Mayhem application can be very easily customised just by passing a configuration object to the constructor:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers'
});

log(app.get('name'));</code></pre>
							<pre class="align-bottom"><code class="javascript">'Bob’s Burgers'</code></pre>
						</div>

						<aside class="tip"><p>The <code>name</code> property of an application will be used as the title of the application in user interfaces that support titles.</p></aside>

						<p>It is also possible to create custom applications by subclassing an existing Application class. For example, the <a href="TODO"><code>mayhem/WebApplication</code> class</a> is a subclass of <code>mayhem/Application</code> with a different default configuration suitable for writing Web applications.</p>

						<aside class="tip"><p><code>mayhem/WebApplication</code> is recommended as the default class for all applications created with the initial release of Mayhem, which focuses primarily on client-side Web apps. Future versions of Mayhem will include more Application subclasses to choose from for native mobile, server-side, and command-line apps.</p></aside>

						<p>Once the application object is ready for use, call <code>app.startup()</code> to start it:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers'
});

log(app.startup().then(function () {
	// started successfully
}, function (error:Error) {
	// an error occurred during startup
}));</code></pre>
							<pre class="align-bottom"><code class="javascript">&lt;Promise></code></pre>
						</div>

						<div class="a half" id="application-components"></div>
						<h3 data-id="application-components">Application components</h3>

						<p>The Application class on its own does relatively little; its power comes in the ability to dynamically load and instantiate different <dfn>application components</dfn> that implement the individual functions necessary to create a complete application. For example, the <a href="TODO"><code>mayhem/binding/Binder</code> class</a> is an application component that is used to perform all data binding within an application, and the <a href="TODO"><code>mayhem/ui/Master</code> class</a> is an application component that is used to provide a user interface.</p>

						<p>The default Mayhem application components can be overridden with custom implementations. However, keep in mind that some parts of the framework that require features from application components expect them to exist at specific keys on the Application instance:</p>

						<ul>
							<li><code><strong>binder</strong></code>: An implementation of the <a href="TODO"><code>mayhem/binding/interfaces.IBinder</code></a> interface. Provides data binding.</li>
							<li><code><strong>errorHandler</strong></code>: An implementation of the <a href="TODO"><code>mayhem/interfaces.IErrorHandler</code></a> interface. Provides error handling for an application.</li>
							<li><code><strong>router</strong></code>: An implementation of the <a href="TODO"><code>mayhem/routing/interfaces.IRouter</code></a> interface. Provides navigation &amp; application state management.</li>
							<li><code><strong>scheduler</strong></code>: An implementation of the <a href="TODO"><code>mayhem/interfaces.IScheduler</code></a> interface. Provides event scheduling.</li>
							<li><code><strong>ui</strong></code>: An implementation of the <a href="TODO"><code>mayhem/ui/Master</code></a> interface. Provides user interface support.</li>
						</ul>

						<p>Application components can be dynamically added to an application at runtime using the <a href="TODO"><code>components</code></a> property of the configuration object. The configuration object gets <a href="TODO">deep copied</a> onto the default configuration, so default application components will continue to exist even if they are not set in the configuration object:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: {
		constructor: 'mayhem/binding/Binder',
		bindings: [ /* … */ ]
	},
	/* … */
	burgerStore: {
		constructor: 'app/stores/RestStore',
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<p>The default application components can be disabled by explicitly setting them to <code>null</code>:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: null,
		/* … */
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: null,
	/* … */
	burgerStore: {
		constructor: 'app/stores/RestStore',
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>Removing default application components from any of the built-in Application classes will probably cause Mayhem to break! Only use this technique to disable optional components in your own Application subclasses.</p></aside>

						<p>Deep copying also means that the properties of default application components can be tweaked without having to rewrite the entire component declaration:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: {
			useScheduler: false
		},
		/* … */
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: {
		constructor: 'mayhem/binding/Binder',
		useScheduler: false
	},
	/* … */
}</code></pre>
						</div>

						<p>Using a string value for a <code>constructor</code> property causes the Application instance to dynamically load a module matching the given string once it is started. The value of the module will be used as the constructor function to create a component.</p>

						<p>Application component constructors can also be explicitly imported and provided directly, which helps to automate <a href="TODO">build-time dependency resolution</a>:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');
import RestStore = require('./stores/RestStore');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		binding: null,
		burgerStore: {
			constructor: RestStore,
			target: '/rest/burgers/'
		}
	}
});

log(app.get('components'));</code></pre>
							<pre class="align-bottom"><code class="javascript">{
	binding: null,
	scheduler: { /* ... */ },
	burgerStore: {
		constructor: RestStore(),
		target: '/rest/burgers/'
	}
}</code></pre>
						</div>

						<p>Once the application has been started, it will perform these actions:</p>

						<ol>
							<li>Freeze the <code>components</code> property so it can no longer be modified</li>
							<li>Load modules for any unloaded application components whose <code>constructor</code> properties were strings</li>
							<li>Instantiate all the application components, assigning them each to the corresponding key directly on the Application instance</li>
							<li>Call the <code>startup</code> method on all application components that need to perform additional startup actions</li>
							<li>Wait for all application components to finish starting</li>
							<li>Resolve the returned <code>startup</code> promise</li>
						</ol>

						<aside class="whatAreYouCrazy"><p>Replacing any of the components attached to the Application object once the application has been started is not supported.</p></aside>

						<p>Application components are instantiated using the value of the <a href="TODO"><code>constructor</code></a> property from the configuration object as the constructor function. The rest of the properties on the configuration object, plus an extra <code>app</code> property pointing to the Application instance, are passed as keyword arguments to the constructor:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');
import Observable = require('mayhem/Observable');
import Promise = require('mayhem/Promise');

class BurgerComponent extends Observable {
	constructor(kwArgs?:Object) {
		super(kwArgs);
		log(kwArgs);
	}

	startup():Promise&lt;void> {
		// a component can do its own startup work here,
		// and optionally return a Promise for asynchronous
		// work
		return new Promise(function (resolve:Promise.IResolver&lt;void>) {
			setTimeout(resolve, 1000);
		});
	}
}

var app = new Application({
	components: {
		burgers: {
			constructor: BurgerComponent,
			buns: [ 'regular', 'sesame' ],
			meats: [ 'beef', 'turkey', 'veggie' ],
			toppings: [ 'cheese', 'onion', 'tomato' ]
		}
	}
});

app.startup().then(function () {
	log(app.get('burgers'));
});
</code></pre>
							<pre><code class="javascript">





{
	app: &lt;Application> { /* … */ },
	buns: [ /* … */ ],
	meats: [ /* … */ ],
	toppings: [ /* … */ ]
}











&lt;BurgerComponent> {
	get('app'): &lt;Application> { /* … */ },
	get('buns'): [ /* … */ ],
	get('meats'): [ /* … */ ],
	get('toppings'): [ /* … */ ]
}</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>Application components should always use their own <code>app</code> property to find their owner Application instance. Using an explicit module reference with <code>import</code> or <code>require()</code> is an anti-pattern that makes testing and reuse of application components more difficult. Application components that instantiate other objects should pass the <code>app</code> property to these objects if they also need a reference back to the application.</p></aside>

						<p>Exporting the application object makes it available for direct reference by other modules later:</p>

						<div class="codeMirror">
							<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',

	components: {
		burgerStore: {
			constructor: 'app/stores/RestStore',
			target: '/rest/burgers/'
		}
	}
});

// TODO: `run`
app.startup();

export = app;</code></pre>
						</div>

						<aside class="whatAreYouCrazy"><p>It is strongly recommended to pass the application object directly to constructors instead of having constructor modules explicitly reference the application module. For convenience, the <a href="TODO">data modelling subsystem</a> can be configured with a default application object based on module identifier. This is the only place where this functionality should normally be used.</p></aside>
					</article>

					<article>
						<div class="a" id="data-binding"></div>
						<h2 data-id="data-binding">Data binding subsystem</h2>

						<div class="a half" id="what-is-data-binding"></div>
						<h3 data-id="what-is-data-binding">What is data binding?</h3>

						<p>TODO: Figure here?</p>

						<p><dfn>Data binding</dfn> is a mechanism by which the value of a property on one object is kept in sync with the value of a property of another object. In other words, data binding makes it possible to have a statement <code>a.foo = 'bar'</code> also automatically execute the statement <code>b.foo = 'bar'</code>, ensuring that the properties <code>a.foo</code> and <code>b.foo</code> will always eventually contain the same value.</p>

						<p>One of the most common ways that data binding is used is to keep a user interface in sync with data from a business object. For example, given an application that displays a menu of burgers, when the name or price of one of the items on the menu changes, data binding ensures that the change is automatically reflected by the UI without requiring the programmer to notify the UI to update or re-render.</p>

						<p>Data binding is directional: it is possible to have a <dfn><em>one-way</em> binding</dfn> where only a change to the source property causes the target object to update, or a <dfn><em>two-way</em> binding</dfn> where source and target properties are kept in sync regardless of which is changed. Most data bindings are intended to keep objects in sync with each other, so the default directionality in Mayhem is two-way.</p>

						<div class="a half" id="how-to-data-bind"></div>
						<h3 data-id="how-to-data-bind">How to bind data in Mayhem</h3>

						<p>In Mayhem applications, all data binding is performed by the central <dfn>data binder</dfn> application component. By convention, this component is always created at <a href="TODO"><code>Application#binder</code></a>. Using the data binder, it is possible to create simple bindings between two properties just by calling <a href="TODO"><code>Binder#bind</code></a>:</p>

						<pre><code class="typescript">import BindDirection = require('mayhem/binding/BindDirection');

var binder = this.get('app').get('binder');

var a = { foo: 'bar' };
var b = { foo: null };

// `b.foo` becomes 'bar'
var handle = binder.bind({
	source: a,
	sourcePath: 'foo',
	target: b,
	targetPath: 'foo',
	direction: BindDirection.ONE_WAY
});

// `b.foo` becomes 'blah'
a.foo = 'blah';

// Removes the binding
handle.remove();</code></pre>

						<aside class="tip"><p>Much of the time, data binding in a Mayhem application will be done more concisely using the <a href="TODO">templating system</a>, which provides a declarative mechanism for binding data to the UI. Applications that implement their own UI components programmatically, or that want to create data bindings between non-UI objects, will use the data binder directly.</p></aside>

						<p>With the <a href="TODO">default set of Binding constructors</a>, the data binding system allows you to bind to arbitrarily nested properties, including those that do not exist yet, using normal dotted object syntax:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { foo: null };
var b = { foo: null };

binder.bind({
	source: a,
	sourcePath: 'foo.bar.baz',
	target: b,
	targetPath: 'foo'
});

// `b.foo` becomes 'blah'
a.foo = { bar: { baz: 'blah' } };

// `b.foo` becomes undefined
a.foo = { bar: null };</code></pre>

						<p>If you need to access a property whose name <em>contains</em> a dot, simply escape the dot with a backslash:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { 'foo.bar': 'blah' };
var b = {};

// `b.foo` becomes 'blah'
binder.bind({
	source: a,
	sourcePath: 'foo\\.bar',
	target: b,
	targetPath: 'foo'
});</code></pre>

						<p>It is also possible to more directly observe and modify a property by creating a low-level <a href="TODO"><code>Binding</code></a> object with <a href="TODO"><code>Binder#createBinding</code></a>. <dfn>Binding objects</dfn> are abstractions that allow us to ignore <em>how</em> and <em>where</em> a property is bound and instead focus solely on the value of the bound property:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { foo: 'bar' };

var binding = binder.createBinding&lt;string>(a, 'foo');

binding.observe(function (change:interfaces.binding.IChangeRecord&lt;string>) {
	// When the observed property changes, this function is called
	change.oldValue; // 'bar'
	change.value; // 'blah'
});

binding.get(); // 'bar'

// Causes observe callback to be called
a.foo = 'blah';</code></pre>

						<aside class="tip"><p>You can instantiate specific types of Binding objects directly by calling <code>new Binding(…)</code>, but creating bindings through the data binder allows the system to automatically choose the best type of Binding object for a given object and current environment, and offers improved efficiency by batching change notifications and delegating to existing Binding objects on properties that are bound to more than once.</p></aside>

						<div class="a half" id="binding-arrays"></div>
						<h3 data-id="binding-arrays">Binding to arrays and collections</h3>

						<p>Mayhem’s data binding system comes with additional bindings specifically for monitoring when an array or collection is changed:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var array:string[] = [];
var binding = binder.createBinding&lt;string[]>(array, '*');
binding.observe(function (change:interfaces.binding.IChangeRecord&lt;string>) {
	change.index; // 0
	change.added; // [ 'foo', 'bar' ]
	change.removed; // []
});
binding.get(); // []
array.push('foo', 'bar');
binding.get(); // [ 'foo', 'bar' ]</code></pre>

						<p>This binding is used whenever the object being bound is an array and the path matches the string <code>'*'</code>. This binding can be used as part of a longer path as well, just like all the bindings constructors in Mayhem:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

var a = { foo: [] };
var binding = binder.createBinding&lt;string[]>(a, 'foo.*');
binding.observe(function (change:interfaces.binding.IChangeRecord&lt;string>) {
	change.index; // 0
	change.added; // [ 'foo', 'bar' ]
	change.removed; // []
});
binding.get(); // []
a.foo.push('foo', 'bar');
binding.get(); // [ 'foo', 'bar' ]</code></pre>

						<aside class="whatAreYouCrazy"><p>Due to the limitations of EcmaScript 3/5, when working with arrays that are data bound, modifications must be performed using the array methods (<code>push</code>, <code>pop</code>, <code>splice</code>, etc.). Directly modifying array indices (<code>array[0] = 'foo'</code>) will not cause notifications. This limitation does not exist in environments that support the upcoming <code>Array.observe</code> standard.</p></aside>

						<div class="a half" id="extending-binding"></div>
						<h3 data-id="extending-binding">Adding and extending bindings</h3>

						<p>As with all application components, the default data binder included with Mayhem, <a href="TODO"><code>mayhem/binding/Binder</code></a>, can be replaced by a totally different data binder, if desired:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		binder: {
			constructor: 'app/Binder'
		}
	}
});</code></pre>

						<p>However, this is usually not necessary, since even if you need to bind to something that the default binder doesn’t understand, it is designed to be extensible through the addition of custom Binding object constructors:</p>

						<pre><code class="typescript">import Application = require('mayhem/Application');

var app = new Application({
	name: 'Bob’s Burgers',
	components: {
		binder: {
			// Adding a new BurgerBinding type
			constructors: [ 'app/binding/BurgerBinding' ]
		}
	}
});</code></pre>

						<p>Binding constructors can also be added and removed dynamically while the application is running by calling <a href="TODO"><code>mayhem/binding/Binder#add</code></a>:</p>

						<pre><code class="typescript">var binder = this.get('app').get('binder');

// Adds a new CustomBinding constructor as the top priority constructor
var handle = binder.add(CustomBinding, 0);

// Stops the CustomBinding constructor from being used by the binder
handle.remove();</code></pre>
					</article>

					<article>
						<div class="a" id="routing"></div>
						<h2 data-id="routing">Routing</h2>

						<div class="a half" id="what-is-routing"></div>
						<h3 data-id="what-is-routing">What is routing?</h3>

						<p>In many application frameworks, including Mayhem, <dfn>routing</dfn> is the primary mechanism by which an application manages its state. Usually, this state management is based on an addressable state mechanism (like a URL).</p>

						<p>Routing is performed by the <dfn>router</dfn> application component. This component is responsible for a few things:</p>

						<ul>
							<li>Reacting to changes to the address of the application (for example, from a browser’s address bar);</li>
							<li>Loading and unloading the appropriate views for the new state (for applications with a user interface); and</li>
							<li>Loading and setting the correct view model for a given view state.</li>
						</ul>

						<p>The default <a href="TODO"><code>HashRouter</code></a> router for a Mayhem Web application breaks the task of routing down into individual <dfn>routes</dfn>, each of which allows a different part of an application to manage its own routing. For example, the a menu of burgers might be displayed in a list or a grid view; the route for the menu would instantiate and place the menu view, and also handle telling the view to change how it should be displayed in response to a route state change.</p>

						<p>Other parts of an application can interact directly with the router to change the current route, or to ask the router for the address of a particular route. For example, one Web page may want to </p>

						<p><a href="TODO"><code>HashRouter</code></a> is the default router that is used by <a href="TODO"><code>WebApplication</code></a>. It enables an application to respond to changes to the hash-part of a URL.</p>

						<aside><p class="tip">Future versions of Mayhem will include additional ways to manage application state, including those that work well with applications that don’t have addressable states (undo/redo-based applications).</p></aside>

						<div class="a half" id="defining-routes"></div>
						<h3 data-id="defining-routes">Defining routes</h3>

						<p>TODO: This is weird, these are <a href="http://www.yiiframework.com/doc/guide/1.1/en/basics.controller">MVC controllers</a>.</p>

						<p>TODO: This information does not match reality right now; reality needs to change</p>

						<p>Application routes are defined in a similar manner to <a href="TODO">binding constructors</a>, except each route is given its own unique identifier:</p>

						<pre><code class="typescript">import WebApplication = require('mayhem/WebApplication');

// TODO: Not final syntax
var app = new WebApplication({
	name: 'Bob’s Burgers',
	components: {
		router: {
			defaultRoute: [ 'index' ],
			routes: {
				index: {
					constructor: 'app/pages/Index'
				}
			}
		}
	}
});</code></pre>

						<p>Each Route object is an instance of <a href="TODO"><code>mayhem/routing/interfaces.IRoute</code></a>. Once a <a href="TODO"><code>Route</code></a> is defined, its <code>startup</code> (TODO: “run”) method will be called when the router is first started. Like all other startup methods, a Promise can be returned from this method to perform asynchronous actions, like preloading other modules, or making requests to a server.</p>

						<aside class="tip"><p>Currently, all routes must be registered before the router is started.</p></aside>

						<p>TODO: Routing lifecycle diagram</p>

						<p>The default router in Mayhem is responsible for determining which routes should be activated according to their registered <a href="TODO"><code>path</code></a>. Once the router determines that a route should be activated, its <a href="TODO"><code>enter</code></a> method is called with information about the current state:</p>

						<pre><code class="typescript">TODO</code></pre>

						<p>Because routes are hierarchical, multiple routes may be active at the same time:</p>

						<pre><code class="typescript">TODO</code></pre>

						<p>When multiple routes will be activated, <code>enter</code> is called starting at the highest route and working down until it reaches the bottom of the route tree. Each route can temporarily pause the route change by returning a <code>Promise</code>:</p>

						<pre><code class="typescript">TODO</code></pre>

						<p>All promises must eventually resolve. TODO: What to do about in-progress routing changes that are aborted due to user navigation? Stopping navigation on enter because a user does not have proper access credentials?</p>

						<p>If a route is already active and the router detects a state change that will not deactivate an active route, the <a href="TODO"><code>stateChange</code></a> method will be called on the active route to notify it of a change. TODO: This is still a possibly weird event model. What if the route isn’t being exited but still wants to prevent the change?</p>

						<p>For routes that are currently active that are going to become inactive as the result of a state change, the router will first call the <a href="TODO"><code>beforeExit</code></a> method on all routes that are going to become inactive, starting at the lowest route and working up until it reaches the top of the route tree. If any of these methods throw a <a href="TODO"><code>CancelError</code></a>, or return a <code>Promise</code> that rejects with a <code>CancelError</code>, the routing action will be aborted. This is useful for routes that need to perform an action (for example, to verify that a user wants to navigate away with unsaved changes, or to automatically persist their incomplete changes to storage) prior to exit. TODO: How about unpreventable navigations, like leaving the app? Once all <code>beforeExit</code> handlers have indicated that they are OK with a state change, <a href="TODO"><code>exit</code></a> methods will be called on each of the routes that is being exited, starting again from the lowest route and working up.</p>

						<aside class="tip"><p>Errors are used instead of passing an event with a <code>preventDefault</code> method, or using a boolean return value, in order to provide a standard way for routes to give additional details to the router or other parts of the application about why a routing change was prevented.</p></aside>
					</article>

					<article>
						<div class="a" id="views"></div>
						<h2 data-id="views">Views</h2>

						<div class="a half" id="mayhem-views"></div>
						<h3 data-id="mayhem-views">How views work</h3>

						<p>The view subsystem in Mayhem is different from most other Web application frameworks (Ember, Polymer, Angular, React, etc.) because it fully abstracts the platform UI (i.e. the DOM). This means that unless you are creating a <a href="TODO">custom platform widget</a>, you never touch the DOM directly. This approach requires thinking slightly differently about how user interfaces are created, but it allows you to do several exceptional things:</p>

						<ul>
							<li>Your application can use native UI controls (i.e. real iOS and Android widgets) with few or no changes</li>
							<li>Your application can run from a Web Worker process, ensuring the UI thread is never blocked</li>
							<li>You don’t need to understand complex tree diffing mechanisms like Virtual DOM, since monolithic <code>render</code> methods that rebuild the entire view when something changes aren’t used</li>
							<li>You don’t have to worry about platform bugs or missing features (like Pointer Events), since they can be fully addressed by Mayhem’s UI abstraction layer</li>
						</ul>

						<aside class="tip"><p>Although your code won’t interact with the DOM directly, Mayhem comes with a familiar, HTML-like templating language that makes it easy for Web developers to start creating UIs for Web-only applications using a familiar syntax and more direct control over the DOM.</p></aside>

						<p>Views in Mayhem are composed of multiple widgets and other views. <dfn>Widgets</dfn> are views that represent reusable UI components—text labels, input controls, lists, grids, and so on. Widgets and views can be created using one of three approaches:</p>

						<ul>
							<li><strong>Declarative approach</strong>: using <a href="TODO">view templating</a> to generate a view from markup</li>
							<li><strong>Programmatic approach</strong>: using inheritance to extend the base <a href="TODO"><code>Widget</code></a> class</li>
							<li><strong>Hybrid approach</strong>: extending a View generated declaratively and adding extra features programmatically</li>
						</ul>

						<p>The most common approach for simple applications is to create views declaratively. These are called <dfn>templated views</dfn>:</p>

						<pre><code class="html">&lt;h1>{app.name}&lt;/h1>

&lt;p>What kind of burger do you want?&lt;/p>

TODO: This does not work with dstore collections
&lt;if condition={app.burgers.length}>
	&lt;ul>
		&lt;for each={app.burgers} as="burger">
			&lt;li>
				{burger.name} - {burger.formattedPrice}
			&lt;/li>
		&lt;/for>
	&lt;/ul>
&lt;else>
	Sorry, we have no burgers
&lt;/if></code></pre>

						<p>The <a href="TODO">HTML templating engine</a> is implemented as an <a href="TODO">AMD loader plugin</a>, so loading a templated view is straightforward in most cases:</p>

						<pre><code class="typescript">import WebApplication = require('mayhem/WebApplication');

var app = new WebApplication({
	name: 'Bob’s Burgers',
	burgers: [
		{ name: 'New Bacon-ings', formattedPrice: '$12.50' },
		{ name: 'Pepper Don’t Preach Burger', formattedPrice: '$10.50' },
		{ name: 'Totally Radish Burger', formattedPrice: '$9.25' },
		{ name: 'Chard To A Crisp Burger', formattedPrice: '$9.00' },
		{ name: 'Beets Me Burger', formattedPrice: '$10.00' }
	],
	components: {
		ui: {
			view: 'mayhem/templating/html!app/views/Master.html'
		}
	}
});

app.startup();</code></pre>

						<p>The <a href="#view-templating">view templating</a> section describes the templating language in greater detail.</p>

						<p>

						<div class="a half" id="view-templating"></div>
						<h3 data-id="view-templating">View templating</h3>

						<p>The default templating system in Mayhem is an extension of HTML that overlays data binding, conditionals, loops, custom elements, and other basic features onto the language. <a href="#how-to-data-bind">Data binding paths</a> are placed inside curly brackets (<code>{path}</code> for one-way binding and <code>{{path}}</code> for two-way binding) and bind to the <code>model</code> object (TODO: Should it be the code-behind view object instead? otherwise we’re restricted.) associated with the view:</p>

						<pre><code class="html">{name}</code></pre>
						<pre><code class="typescript">view.set('model', { name: 'foo' });</code></pre>

						<p>Outputs:</p>

						<pre><code class="html">foo</code></pre>

						<p>Using a widget in a view is as simple as using the <code>&lt;widget></code> tag:</p>

						<pre><code class="html">&lt;widget is="mayhem/ui/Label" text={foo}>&lt;/widget></code></pre>

						<p>The value of the <code>is</code> attribute must be a module ID that resolves to a view constructor.</p>

						<p>Mayhem’s HTML templating engine also allows widgets to be registered as custom elements within individual templates, which is useful when the same widget is used multiple times within a template:</p>

						<pre><code class="html">&lt;alias tag="label" to="mayhem/ui/Label">
&lt;label text={foo}>&lt;/label></code></pre>

						<p>This example is equivalent to the previous example, except the <code>&lt;label></code> tag has been aliased to the <code>mayhem/ui/Label</code> widget.</p>

						<p>Because aliases are defined only for the specific template in which they appear, there is no chance of aliases conflicting with aliases from other templates. This is different from Web components, which require custom elements to be registered on the parent document and can cause conflicts when multiple applications run on the same page.</p>

						<p>Mayhem’s HTML templating includes some extra, special tags for conditionals, loops, and Promise handling:</p>

						<ul>
							<li><strong><code>&lt;if></code>, <code>&lt;elseif></code>, and <code>&lt;else></code></strong>: Allows content to be conditionally displayed. Internally, creates an instance of the <a href="TODO"><code>mayhem/templating/html/ui/Conditional</code></a> widget.</li>
							<li><strong><code>&lt;when></code>, <code>&lt;pending></code>, and <code>&lt;rejected></code></strong>: Allows different content to be displayed while a Promise is being resolved. Internally, creates an instance of the <a href="TODO"><code>mayhem/templating/html/ui/Promise</code></a> widget.</li>
							<li><strong><code>&lt;for></code></strong>: Allows simple iteration over an array or <a href="TODO">Collection</a>. Internally, creates an instance of the <a href="TODO"><code>mayhem/templating/html/ui/Iterator</code></a> widget.</li>
						</ul>

						<h4>Conditional display</h4>

						<p>TODO: It would be nice to eliminate the “condition=” part</p>
						<pre><code class="html">&lt;if condition={foo}>
	Has a foo
&lt;elseif condition={bar}>
	Has a bar
&lt;else>
	No foo, no bar
&lt;/if></code></pre>

						<aside class="tip"><p>This mechanism is designed only to show and hide blocks of widgets. Conditional attributes should be handled by creating a specific <a href="TODO">view–model</a> and binding the attribute to a <a href="TODO">computed property</a> on the model.</p></aside>

						<h4>Promise handling</h4>

						<pre><code class="html">&lt;when value={foo} as="fooValue">
	foo is resolved to {fooValue}
&lt;pending>
	Please wait for foo
&lt;rejected as="fooError">
	foo was rejected because {fooError.message}
&lt;/when></code></pre>

						<h4>Iterator</h4>

						<pre><code class="html">&lt;for each={foo} as="item">
	{item.name}
&lt;/for></code></pre>

						<aside class="tip"><p>The iterator widget is a dumb widget that will always attempt to fetch and render all items from an array or collection. Use a <a href="TODO"><code>mayhem/ui/ListView</code></a> or <a href="TODO"><code>mayhem/ui/GridView</code></a> when you need to render large collections with full lazy-loading and resource management. TODO: This is not true now, but should be, since dgrid can’t do MultiNodeWidget.</p></aside>

						<div class="a half" id="cross-platform-views"></div>
						<h3 data-id="cross-platform-views">Using cross-platform views</h3>

						<p>Mayhem’s view system is designed so that the underlying rendering platform (DOM, iOS, Android, Node.js streams, etc.) is never exposed to an application under normal use. This means that Mayhem applications can be written to run seamlessly across multiple platforms, using native UI controls, without having to rewrite the application in a different language, and without having to emulate the UI features of the target platform.</p>

						<p>In order to create a cross-platform application, it’s necessary to use the standard set of widgets.</p>

						<div class="a half" id="event-system"></div>
						<h3 data-id="event-system">The event system</h3>

						<p>In addition to displaying information to a user interface, the view system is also responsible for receiving input from a user interface that can be used to execute functions within an application in response to interaction. To do this, Mayhem provides an event abstraction system that normalises input from different view implementations into a standard event model.</p>

						<p>The standard event model in Mayhem translates all pointer inputs (mouse, pen, touch, etc.) into standard <a href="TODO"><code>PointerEvent</code></a> objects that closely match the W3C Pointer Events API, and keyboard events into standard <a href="TODO"><code>KeyboardEvent</code></a> objects that closely match the latest DOM 3 Events API:</p>

						<pre><code class="typescript">TODO: example</code></pre>

						<p>It is possible to easily create custom events, such as gestures, using <a href="TODO">extension events</a> that listen for lower-level events and then dispatch the custom events when the custom event’s criteria are satisfied:</p>

						<pre><code class="typescript">TODO: example</code></pre>

						<div class="a half" id="custom-platform-widgets"></div>
						<h3 data-id="custom-platform-widgets">Custom platform widgets</h3>

						<p>When creating custom platform widgets, the <code>_render</code> method can be used to generate native UI controls knowing that all initial properties from the <code>kwArgs</code> object have been set. This method will only ever be invoked <em>once</em>. There is no guarantee about exactly when this method will be invoked, except that it will always be after all <code>kwArgs</code> properties have been set but before the widget is attached to the view tree.</p>

						<p>Custom widgets should do their best to only do anything while their <code>isAttached</code> property is <code>true</code>. When <code>isAttached</code> is <code>false</code>, the widget is not attached to the view tree, and any UI updates performed in this condition are a waste of time. Widgets should not use the <code>detach</code> method as an indicator to halt operations since this method is used a widget is simply moved from one part of the UI to another.</p>

						<p>TODO: There should probably be rendering lifecycle methods to avoid <code>isAttached</code> churn?</p>
					</article>
				</main>
			</div>
		</div>
		<script src="css/highlight.pack.js"></script>
		<script src="css/main.js"></script>
	</body>
</html>
