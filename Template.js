define([
	'require',
	'dojo/_base/array',
	'dojo/_base/lang',
	'dojo/dom-construct',
	'dojo/on',
	'dojo/aspect',
	'dojo/string'
], function (require, array, lang, domConstruct, on, aspect, string) {
	// in addition to this plugin, there should be a counterpart for the build system that will
	// compile the strings, output an AMD module that exports the compiled template, and updates
	// module ids in the reference module to replace the whole "framework/template!./some/module"
	// dependency with "./some/module".

	// during development, if you're using a module that is already compiled, just don't provide
	// an extension for the module id and it will be assumed to be compiled eg:
	//	not compiled:
	//		'framework/Template!./template/View.html'
	//	compiled:
	//		'framework/Template!./template/View'


	function Template(renderer) {
		lang.mixin(this, renderer);
	}

	Template.prototype = {
		constructor: Template,

		render: function (view) {
			//	summary:
			//		Generates a DOM structure and returns a single node.  This function is replaced
			//		by the compiled function generated by framework/template/compiler.
			//	view: framework/View
			//		The view to be rendered.  It should have the following properties:
			//		* viewModel: The context for variable lookup in the template
			//		* subViews (object): An object where the keys map to the names of the
			//		  placeholders and the values are ordered arrays of Views that are to be located
			//		  in those placeholders

			// a default implementation that should be overridden
			return document.createElement('div');
		},

		on: on,

		aspect: aspect,

		domCreate: domConstruct.create,

		htmlEscape: function (str) {
			return str.replace(/&/g, '&amp;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;')
				.replace(/\"/g, '&quot;')
				.replace(/'/g, '&#039;');
		},

		toDom: domConstruct.toDom,
		emptyNode: domConstruct.empty,
		placeNode: domConstruct.place,

		destroy: function () {
			// TODO:
		}
	};

	var includesExtension = /\..*$/,
		templateCache = {};

	Template.load = function (id, moduleRequire, load) {
		//	summary:
		//		An AMD plugin for loading templates.  This handles both raw and compiled templates.

		// for templates without an extension, treat them like an AMD dependency.  this implies a
		// compiled template

		function complete(renderer) {
			var template = new Template(renderer);

			templateCache[sourceUrl] = template;

			load(template);
		}

		var sourceUrl = moduleRequire.toUrl(id),
			cachedTemplate = templateCache[sourceUrl];

		if (cachedTemplate) {
			return load(cachedTemplate);
		}

		if (!includesExtension.test(id)) {
			moduleRequire([id], complete);
		}
		// templates with extensions are treated like a text file.
		// we lazy-load the compiler so that we don't need to include it after a build.
		else {
			// ./template/compiler is our code to parse and compile the template string.  this
			// same module would be leveraged by the build plugin to produce the compiled
			// function exported by the AMD module that replaces this dependency.
			require(['./template/compiler', 'dojo/text!' + id], function (compile, templateString) {

				var renderer = compile(string.trim(templateString), {
						sourceUrl: moduleRequire.toUrl(id),
						toDom: domConstruct.toDom
					});

				// TODO: cache the results based on sourceUrl?

				// ensure any deps we found in the template will be pre-loaded.
				// TODO: relative deps will be loaded relative to the View that uses this template.
				// it would be more intutive to make deps relative to the template. ids should be
				// adjusted to work like that.
				moduleRequire(renderer.deps || [], function () {
					complete(renderer);
				});
			});
		}
	};

	return Template;
});