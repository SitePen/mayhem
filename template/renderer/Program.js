define([
	'./Renderers'
], function (Renderers) {

	function ProgramRender(program) {
		//	summary:
		//		Constructor for an object that manages the rendering of a "program"
		//	program:
		//		The list of AST nodes to be rendered

		var sourceSlots = program.slots,
			inverse = program.inverse,
			// TODO: do these slots work for nested slots/blocks/programs?
			slots = this.slots = {},
			slot,
			k;

		this.statements = new Renderers.Statements(program.statements);
		for (k in sourceSlots) {
			slot = sourceSlots[k];
			slots[k] = new Renderers[slot.type](slot);
		}

		if (inverse) {
			this.inverse = new Renderers.Statements(inverse.statements);
			sourceSlots = inverse.slots;
			for (k in sourceSlots) {
				slot = sourceSlots[k];
				// since each slot should have unique ids per template, we can merge the statements
				// and inverse slots and put them in one location so that logic further along
				// doesn't need to understand if we are in the inverse branch or not.
				slots[k] = new Renderers[slot.type](slot);
			}
		}
	}

	ProgramRender.prototype = {
		constructor: ProgramRender,

		render: function () {
			//	summary:
			//		Invoke the renderers for each of the statements associated with this program.
			//	returns: array
			//		The list of output generated by the program

			// if anything wants to render the inverse, they need to directly invoke
			// program.inverse.render(); rather than program.render();
			var statements = this.statements;
			return statements.render.apply(statements, arguments);
		},

		unrender: function () {

		},

		destroy: function () {

		}
	};

	return ProgramRender;
});